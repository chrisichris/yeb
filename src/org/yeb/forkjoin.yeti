/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module org.yeb.forkjoin;

import java.util.concurrent:ForkJoinTask,
							ForkJoinPool,
							RecursiveTask,
							Future;
							
import java.lang:ThreadLocal, Throwable;

std = load org.yeb.std;

typedef converter<a> = ~Object -> a;

typedef taskStruct<a> = {
    task is ~ForkJoinTask,
    converter is converter<a>
}

pool = new ForkJoinPool();

blocking fn = 
   (import java.util.concurrent:ForkJoinPool,ForkJoinPool$ManagedBlocker;
    var v = none;
    mutex = new Object();
    class MyBlocker extends ForkJoinPool$ManagedBlocker 
        boolean block()
            synchronized mutex \(
                case v of
                None _ : 
                    try
                        v := Some (fn());
                    catch Throwable th:
                        v := Exception th;
                    yrt;
                _: ()
                esac);
            true,
        boolean isReleasable()
            synchronized mutex \(
                case v of
                None _ : false;
                _ : true;
                esac)
    end;
    ForkJoinPool#managedBlock(new MyBlocker());
    synchronized mutex \(
        case v of
        Some va: va; 
        Exception th: throw (th is ~Throwable);
        None _: failWith "Must not happen";
        esac));


newTaskStruct task converter = 
	   (import java.util.concurrent.ForkJoinTask;
        monitor = std.currentMonitor;
        monitor.register \(_ = (task is ~ForkJoinTask)#cancel(true));
		{
			task,
			converter is ~Object -> 'a,
            monitor = std.currentMonitor
		});
	
recursiveTask fn is (() -> 'a) -> taskStruct<'a> = 
   (moni = std.currentMonitor;
    class StdRecursiveTask extends RecursiveTask
		Object compute()
			(std.withMonitor moni fn) unsafely_as ~Object,
	end;
	newTaskStruct
            (new StdRecursiveTask ()) 
			do x: x unsafely_as 'a done);

blockingTask fn =
   recursiveTask \(blocking fn);
            

callbackTask cbfn is (((Value 'a | Exception 't) -> ()) -> 'r2) -> taskStruct<'a>=
   (monitor = std.currentMonitor;
    class StdAsyncForkJoinTask extends ForkJoinTask
		var result = () unsafely_as ~Object,
		
		boolean exec()
            cbfn do ath:
                    std.withMonitor monitor 
                        \case ath of
                        Value a: 
                            this#complete(a unsafely_as ~Object);
                        Exception t:
                            this#completeExceptionally(t is ~Throwable);
                        esac;
                done;
			false,
		
		void setRawResult(Object res)
			result := res,
		Object getRawResult()
			result
	end;
	task = new StdAsyncForkJoinTask();  
	newTaskStruct 
        (task unsafely_as ~ForkJoinTask)
		do x:x unsafely_as 'a done);
    

_map fn task is ('a -> 'b) -> taskStruct<'a> -> taskStruct<'b> =
	task with {
		converter obj = fn (task.converter obj)
	};
	
	
execute taskStruct = 
	taskStruct.converter (pool#invoke(taskStruct.task));

   
invoke taskStruct is taskStruct<'a> -> 'a= 
    if ForkJoinTask#inForkJoinPool() then
		taskStruct.converter 
			((taskStruct.task is ~ForkJoinTask)#invoke());
	else
		taskStruct.converter
			(pool#invoke(taskStruct.task))
	fi;
	
invokeAll taskStructs is list<taskStruct<'a>> -> list<'a>=
	if ForkJoinTask#inForkJoinPool() then
		toexec = taskStructs |> map do stru:
			stru.task is ~ForkJoinTask
		done;
		ForkJoinTask#invokeAll(array toexec);
		taskStructs |> map do stru:
			r = (stru.task is ~ForkJoinTask)#get();
			stru.converter r;
		done;
	else
		taskStructs |> map do {task, converter}: 
				{
					future = pool#submit(task is ~ForkJoinTask),
					converter
				}
			done
		|> map do {future, converter}:
				converter ((future is ~ForkJoinTask)#get());
			done;
	fi;	

	
		
    
        
    


{
	pool,
	map fn task = _map fn task,
	recursiveTask, 
	blockingTask,
    callbackTask,
    blocking,
	execute, 
	invoke, 
	invokeAll,
} 
	