/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module org.yeb.forkjoin;

import java.util.concurrent:ForkJoinTask,
							ForkJoinPool,
							RecursiveTask,
							Future;
							
import java.lang.Throwable;

std = load org.yeb.std;

typedef converter<a> = ~Object -> a;

typedef taskStruct<a> = {
    task is ~ForkJoinTask,
    converter is converter<a>
}


pool = new ForkJoinPool();

newTaskStruct task converter = 
	   (import java.util.concurrent.ForkJoinTask;
		{
			task is ~ForkJoinTask,
			converter is ~Object -> 'a
		});
	
recursiveTask fn is (() -> 'a) -> taskStruct<'a> = 
   (class StdRecursiveTask extends RecursiveTask
		Object compute()
			res = (fn ()) unsafely_as ~Object;
			res,
	end;
	newTaskStruct (new StdRecursiveTask ()) 
			do x: x unsafely_as 'a done);

completableTask execFn converter is 'efn -> converter<'a> -> taskStruct<'a> =
   (class StdAsyncForkJoinTask extends ForkJoinTask
		var result = () unsafely_as ~Object,
		
		boolean exec()
			(execFn this) is boolean,
		
		void setRawResult(Object res)
			result := res,
		Object getRawResult()
			result
	end;
	task = new StdAsyncForkJoinTask();
	newTaskStruct 
		(task unsafely_as ~ForkJoinTask)
		converter);


_map fn task is ('a -> 'b) -> taskStruct<'a> -> taskStruct<'b> =
	task with {
		converter obj = fn (task.converter obj)
	};
	
	
execute taskStruct = 
	taskStruct.converter (pool#invoke(taskStruct.task));

   
invoke taskStruct is taskStruct<'a> -> 'a= 
    if ForkJoinTask#inForkJoinPool() then
		taskStruct.converter 
			((taskStruct.task is ~ForkJoinTask)#invoke());
	else
		taskStruct.converter
			(pool#invoke(taskStruct.task))
	fi;
	
invokeAll taskStructs is list<taskStruct<'a>> -> list<'a>=
	if ForkJoinTask#inForkJoinPool() then
		toexec = taskStructs |> map do stru:
			stru.task is ~ForkJoinTask
		done;
		ForkJoinTask#invokeAll(array toexec);
		taskStructs |> map do stru:
			r = (stru.task is ~ForkJoinTask)#get();
			stru.converter r;
		done;
	else
		taskStructs |> map do {task, converter}: 
				{
					future = pool#submit(task is ~ForkJoinTask),
					converter
				}
			done
		|> map do {future, converter}:
				converter ((future is ~ForkJoinTask)#get());
			done;
	fi;	

asyncTask opts fn is 'o -> (() -> 'a) -> taskStruct<'a>=
    completableTask do task:
			_ = std.async opts do: 
				try
					task#complete((fn ()) unsafely_as ~Object);
				catch Throwable th:
					task#completeExceptionally(th);
				yrt;
			done;
			false;
		done
		do x: x unsafely_as 'a done;
	
callbackTask cbfn is (((Value 'a | Exception 't) -> ()) -> 'r2) -> taskStruct<'a>=
    completableTask 
		do task:
			_ = cbfn do ath:
				case ath of
					Value a: 
						task#complete(a unsafely_as ~Object);
					Exception t:
						task#completeExceptionally(t is ~Throwable);
				esac;
			done;
			false
		done
		do x:x unsafely_as 'a done;
		
	

async opts fn =
	invoke (asyncTask opts fn);

{
	pool,
	map fn task = _map fn task,
	recursiveTask, 
	completableTask, 
	callbackTask,
	asyncTask,
	async,
	execute, 
	invoke, 
	invokeAll,
} 
	