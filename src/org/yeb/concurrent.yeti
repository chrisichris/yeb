module org.yeb.concurrent;

import java.util.concurrent:ForkJoinPool;
import java.util.concurrent.atomic:AtomicBoolean, AtomicLong;

load org.yeb.std;

linkableCounter = new AtomicLong();

typedef linkable = {
    alive is ~AtomicBoolean,
    cid is number,
    alive? is boolean,
    linked is hash<linkable, KillOther () | InformOther (linkable -> linkable -> ())>
}; 

    

newLinkable () is () -> linkable = 
   (alive = new AtomicBoolean(true);
    cid = linkableCounter#incrementAndGet();
    linked = [:];

    {
        alive,
        get alive? () = alive#get(),
        cid,
        linked
    });

shutdownLinkable killedAc =
    if (killedAc is linkable).alive#compareAndSet(true,false) then
        forHash 
            (synchronized killedAc.linked \(
                ret = copy killedAc.linked;
                clearHash killedAc.linked;
                ret))
            do liveAc lt:
                case lt of
                KillOther ():
                    ();
                InformOther fn :
                   (synchronized liveAc.linked \(delete liveAc.linked killedAc);
                    fn liveAc killedAc);
                esac;
            done
    fi;

killLinkable killedAc =
    if (killedAc is linkable).alive#compareAndSet(true, false) then
        lis = synchronized killedAc.linked \(
            ret = copy killedAc.linked;
            clearHash killedAc.linked;
            ret);
        forHash lis do liveAc lt:
            case lt of
            KillOther () :
               (synchronized liveAc.linked \(delete liveAc.linked killedAc);
                killLinkable liveAc); 
            InformOther fn :
               (synchronized liveAc.linked \(delete liveAc.linked killedAc);
                fn liveAc killedAc);
            esac;
        done
    fi;
    
linkLinkable ac1 lt1 ac2 lt2 =
   (killInform liveAc lt killedAc =
        case lt of
        KillOther () :
            (synchronized liveAc.linked \(delete liveAc.linked killedAc);
             killLinkable liveAc); 
        InformOther fn :
            (synchronized liveAc.linked \(delete liveAc.linked killedAc);
             fn liveAc killedAc);
        esac;
        
    if (ac1 is linkable).cid == (ac2 is linkable).cid then
        ();
    else
        m1 = if ac1.cid > ac2.cid then ac2.linked else ac1.linked fi;
        m2 = if ac1.cid > ac2.cid then ac1.linked else ac2.linked fi;
        doAfter = synchronized m1 \(synchronized m2 \(;
            if ac1.alive? and ac2.alive? then
                ac1.linked.[ac2] := lt1;
                ac2.linked.[ac1] := lt2;
                \()
            elif not ac1.alive? then
                \(killInform ac2 lt1 ac1)
            elif not ac2.alive? then
                \(killInform ac1 lt2 ac2)
            else 
                \()
            fi
            ));
        doAfter ();
    fi);

//----REACTOR--------------------------------------------------------
    
currentReactor = threadLocal none;


reactor opts = 
   (import java.util.concurrent.atomic:AtomicReference, AtomicInteger, 
                                       AtomicBoolean;
    import java.util.concurrent:Executor, ExecutorService;
    import java.lang:Runnable;
    
    linkable = newLinkable();
    
    
    var executor = defaultExecutor;
    var log = getLogger "org.yeb.std.reactor.\(linkable.cid)";
    var linkParent = KillOther ();
    
    for opts do opt:
        case opt of
        Executor exs: executor := exs;
        Logger l: log := l; 
        Monitor fn: linkParent := InformOther fn;
        esac;
    done;

    
    case currentReactor.value of 
        Some ol :
            linkLinkable linkable linkParent ol (KillOther ());    
        None _ : ()
    esac;
    
    flushing = new AtomicBoolean(false);
    lock = new Object();
    var queue = array [];
    
    class FlushRunnable extends Runnable 
        void run()
            buffer = synchronized lock \(
                ((empty? queue) and linkable.alive#get()) loop
                    lock#wait();
                buffer = queue;
                queue := array [];
                buffer);
            
            if linkable.alive#get() then 
                try 
                    for buffer do fn:
                        if linkable#alive#get() then
                            fn()
                        fi;
                    done;    
                catch Exception ex:
                    log#error("Error in actor [\(linkable.cid)]",ex);
                    killLinkable linkable;
                yrt;
                
                _ = flushing#compareAndSet(true,false);
            
                if synchronized lock \(not empty? queue) then
                    if flushing#compareAndSet(false,true) then
                        executor#execute(this);
                    fi
                fi
            fi
    end;
    
    flushRunnable = new FlushRunnable();
   
    execute fn =
        if linkable.alive#get() then
            synchronized lock \(
                push queue fn;
                lock#notify());
            if flushing#compareAndSet(false,true) then
                executor#execute(flushRunnable);
            fi
        fi;
    p = linkable with {
        execute,
        log,
        shutdown () = shutdownLinkable linkable,
        kill () = killLinkable linkable,
    };
    
   
    nexecute fn = withThreadLocal 
                currentReactor 
                (Some (p with {execute fn2 = nexecute fn2}))
                do: execute fn done;
    
    p with {execute fn = nexecute fn});

asyncPipe asyncFn receiverFn = 
    case currentReactor.value of
    Some reac :
        _ = async [] \(
            r = asyncFn ();
            reac.execute \(receiverFn r));
    None _ : 
        _ =receiverFn (asyncFn ());
    esac;

    
future opts fn = 
   (import java.util.concurrent.atomic:AtomicMarkableReference;
    import java.util.concurrent:TimeoutException;
    
    var timeout = 0;
    for opts do opt:
        case opt of
        Timeout nu: timeout := nu;
        esac
    done;
    
    ref = new AtomicMarkableReference(() as ~Object, false);
    lock = new Object();
    
    (fn is ( 'a -> () ) -> () ) do v :
        if ref#isMarked() then
            failWith "value already set only set once";
        fi;
        synchronized lock \(
            _ = ref#set((v is 'a) unsafely_as ~Object,true);
            lock#notifyAll());
        ()
    done;
            
    do:
        if ref#isMarked() then
            ref#getReference() unsafely_as 'a;
        else
            if timeout < 1 then
                synchronized lock \(
                    ref#isMarked() loop lock#wait());
            else
                synchronized lock \(lock#wait(timeout));
            fi;
            if ref#isMarked() then
                ref#getReference() unsafely_as 'a;
            else 
                throw new TimeoutException();
            fi;
        fi
    done); 
    
reactRsp opts reactor fn =     
    future opts do rfn: 
        reactor.execute do: rfn fn done
    done;            
 
        
{
    (|~>) fn1 fn2 = asyncPipe fn1 fn2,

    newLinkable,
    shutdownLinkable,
    linkLinkable,
    killLinkable,
    
    reactor,
    reactRsp,
    asyncPipe,
    future,
}