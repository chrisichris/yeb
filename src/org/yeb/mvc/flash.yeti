module org.yeb.mvc.flash;

load org.yeb.mvc.webutils;

flashKey = "org.yeb.session.flash";

/**
 * request filter wich is used to prepare request for flash
 */
handler handler ctxt = 
   (sess = (request ctxt)#getSession(true);
    //synchronized on session lazly create the flash structure
    flashStruct = synchronized sess do _:
        f = sess#getAttribute(flashKey);
        flashStruct = if not defined? f then
            fr = {var oldMap = new java.util.HashMap(),
                  var newMap = new java.util.HashMap()};
            sess#setAttribute(flashKey, fr);
            fr;
        else
            f unsafely_as {var oldMap is ~java.util.HashMap,
                           var newMap is ~java.util.HashMap}
        fi;
        //store in the request
        (request ctxt)#setAttribute(flashKey,flashStruct);
        flashStruct;
    done;
    //synchronized on the flashstruct do the rest of the
    //request handling
    synchronized flashStruct do _:
        try
            handler ctxt
        finally
            //do the cleanup again synchronized on the session
            synchronized sess do _:
                flashStruct.oldMap#clear();
                om = flashStruct.oldMap;
                flashStruct.oldMap := flashStruct.newMap;
                flashStruct.newMap := om;
                sess#setAttribute(flashKey,flashStruct);
            done;
        yrt;
    done);


getStruct ctx =
   (ra = (request ctx)#getAttribute(flashKey);
    if not defined? ra then
        failWith "no FlashContext: flash acces must be wrapped in a flashHandler";
    else
        ra unsafely_as {var oldMap is hash<string,~Object>, 
                        var newMap is hash<string, ~Object>}
    fi);

/**
 * takes the given value.
 *
 * After the value is taken it is not in the session anymore.
 */ 
take ctx key is 'b -> string -> (None () | Some 'a) = (
    fc = getStruct ctx;
    if key in fc.newMap then
        Some (fc.newMap.[key] unsafely_as 'a);
    elif key in fc.oldMap then
        Some (fc.oldMap.[key] unsafely_as 'a);
    else
        none
    fi);

/**
 * puts the value in the flashsession.
 * A value put in the flashsession remains in there only until the next request
 */
put ctx key value =
   (getStruct ctx).newMap.[key] := (value unsafely_as ~Object);

/**
 * reads the value from the falshsession and makes sure that it reamains in there
 * also for the next request.
 */ 
peek ctx key =
   (r = take ctx key;
    case r of
        Some v: put ctx key v;
        None _: ();
    esac;
    r);

{
    handler,
    key = flashKey, 
    take, 
    put,
    peek,
}