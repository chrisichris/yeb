/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module org.yeb.mvc.handler;



import java.lang: Thread, System, 
				  ClassLoader, Character, CharSequence,
				  Runnable;
import java.util: Locale, Date, Collection;
import java.util.regex:Pattern;
import java.util.concurrent.ConcurrentHashMap;
import java.text:NumberFormat, DecimalFormat, DateFormat, SimpleDateFormat;
import java.net: URLEncoder, URLDecoder;
import java.io:File;

import javax.servlet: ServletContext, FilterChain,ServletException,
                      AsyncContext, ServletRequest, AsyncListener;
import javax.servlet: Filter,FilterConfig,ServletRequest,ServletResponse,
					  DispatcherType;
import javax.servlet.http: HttpServletRequest, HttpServletResponse,HttpSession,
							Part;

import org.springframework.mock.web: MockFilterConfig, MockServletContext, 
    MockHttpServletRequest, MockHttpServletResponse,MockFilterChain;
import org.springframework.web.util.WebUtils;

import yeti.lang: Fun, Struct;
import org.yeb:ValidationException, YebUtils;

load org.yeb.std;
load org.yeb.mvc.webutils;
load org.yeb.validation;

typedef handlerResult = Completed string | NotHandled string | Handling string;
typedef handlerType<a> = a -> handlerResult;
typedef handlerAdapterType<a> = handlerType<a> -> handlerType<a>;
     
     
///creates the context used in the handlers. This function is mainly used 
///internally by the yebfilter. For testing use mockCtxt
rootCtxt pathInfo sctxt req res asyncContext = 
   (reqn = new YebHttpServletRequestWrapper(() as ~Locale, "",
                                        pathInfo,() as ~java.util.Map, req);
                                        
    timeoutMonitor = monitor ();
    (asyncContext is ~AsyncContext)#addListener(asyncListener do ev:
        case ev of
        OnTimeout ev: timeoutMonitor.fire ();
        _ : ()
        esac
    done);
	{
		asyncContext is ~AsyncContext,
		req = reqn as ~HttpServletRequest,
		res is ~HttpServletResponse,
		sctxt is ~ServletContext,
        monitor = timeoutMonitor,
	});
		


class YebMockAsyncContext(ServletRequest req, ServletResponse res) extends AsyncContext
	
	var timeout = 1000,
	var request = req,
	void addListener(AsyncListener lis)
		(),
	void addListener(AsyncListener lis, ServletRequest req, ServletResponse res)
		(),
	
	void complete() (),
	
	AsyncListener createListener(Class cl)
		failWith "Not supported",
	
	void dispatch() (),
	
	void dispatch(ServletContext ctxt, String path) (),
	void dispatch(String path) (),
	ServletRequest getRequest() request,
	void setRequest(ServletRequest req) request := req,
	ServletResponse getResponse() res,
	long getTimeout() timeout,
	void setTimeout(long t) timeout := t,
	boolean hasOriginalRequestAndResponse() true,
	void start(Runnable ra) failWith "Not supported"
end;

class YebMockHttpServletRequest(MockServletContext ctxt, String reqMethod, String reqPath, MockHttpServletResponse resp) extends MockHttpServletRequest(ctxt,reqMethod, reqPath)
	var asyncContext = new YebMockAsyncContext((),resp),
	
	//void init() asyncContext#setRequest(this),
	
	AsyncContext getAsyncContext() asyncContext,
	boolean isAsyncStarted() true,
	boolean isAsyncSupported() true,
	AsyncContext startAsync() 
		asyncContext := new YebMockAsyncContext(this, resp);
		asyncContext,
		
	AsyncContext startAsync(ServletRequest req, ServletResponse res)
		asyncContext := new YebMockAsyncContext(req,res);
		asyncContext,
		
	Collection getParts () failWith "Not implemented",
	Part getPart(String name) failWith "Not implemented",
	boolean authenticate(HttpServletResponse resp) failWith "Not implemented",
	void logout() (),
	DispatcherType getDispatcherType() failWith "Not implemented",
	void login(String name, String pwd) failWith "Not implemented"
	
	
end;
	
newMockHttpServletRequest method path =
	new YebMockHttpServletRequest(new MockServletContext(), method is string, path is string, new MockHttpServletResponse());  

    
/** creates a mockCtxt for testing handlers. 
 *   Use Get Post Head etc to specifiy the path. 
 *   :mockCtxt [Get "index.html"]
 *   
 *   Use Header hash<string,string>, Param hash<string,string>, to spcify param
 *   :mockCtxt [Get "index.html", Header ["accepted":"..."], Param["foo","value"]]
 *   
 *   Use Params to specify many parameter arrays
 *   :mockCtxt [Post "form", Params ["values":["1","2"]]]
 */
mockCtxt opts = 
   (var reqMethod = "GET";
    var reqPath = "/";
    var resourcePath = "test/resources/webapp";
    var headers = [:];
    var params = [:];
    for opts do opt:
        case opt of
        Get ruri : (reqMethod := "GET";reqPath := ruri);
        Head ruri : (reqMethod := "HEAD";reqPath := ruri);
        Post ruri : (reqMethod := "POST";reqPath := ruri);
        Put ruri : (reqMethod := "PUT";reqPath := ruri);
        Delete ruri : (reqMethod := "DELETE";reqPath := ruri);
        Trace ruri : (reqMethod := "TRACE";reqPath := ruri);
        Connect ruri : (reqMethod := "CONNET";reqPath := ruri);
        ResourcePath str: resourcePath := str;
        Header ha: forHash ha do k v: headers.[string k] := string v done;
        Param ha: forHash ha do k v: 
                params.[string k] := array [(string v) unsafely_as ~String] 
            done;
        Params ha : forHash ha do k v:
                params.[string k] := 
                    array (map do ve: 
                            (string ve) unsafely_as ~String 
                           done v)
            done;
        esac;
    done;


    mockServletCtxt = new MockServletContext(resourcePath);
    mockRes = new MockHttpServletResponse();
    mockReq = new YebMockHttpServletRequest(mockServletCtxt,reqMethod, reqPath,mockRes);

    forHash params do k v:
        mockReq#addParameter(k,v);
    done;
    forHash headers do k v:
        mockReq#addHeader(k,v);
    done;

    ctxt = rootCtxt reqPath mockServletCtxt mockReq mockRes mockReq#startAsync();
	
	
    nc = ctxt with {
        mockServletCtxt,
        mockReq,
        mockRes,
    };
    nc;
);


//HandlerAdapters


idHandler handler is handlerAdapterType<'a> = handler;


/**
 * Transform an url pattern to a regex. Patterns are used in routers to 
 * specify path pattern which should be handled.
 *
 * ie for the pattern:
 * :/entry/:id/:date
 * becomes the regex
 * :/entry/([^/]+)/([^/]+)/(.*)
 * and the matched parts are exposed as request-parameters
 *
 * to specify a custom regex put it between $ $ after the name of the part.
 * ie to specify that id should only contain digits:
 * :/entry/:id$d+$
 */
urlPatternToRegex pat = 
   (//:a-z is name
    //:a-z? is optional
    //* at end means rest
    //$marks start regex $ marks end regex
    
    import java.util.regex.Pattern;
    
    paS = if strEnds? pat "/*" then 
                    strLeft pat (strLength pat - 2)
               else
                    pat;
               fi;
               
    tokens = matchAll '(/?\.?):(\w+)(\$([^\$]+)\$)?(\?)?' (Token . tail) Text paS;
    
    names = tokens 
        |> map do t:
            case t of
            Token [leading, name, foo, regex, mark]: Some name;
            _ : none;
            esac
        done
        |> catSome
        |> array;
    
    reg = tokens
    |> map do x:
        case x of
        Token [leading, name, foo, regex, mark]:
           (reg = if defined? regex and (strLength regex > 0) then 
                    regex;
                  else
                    '[^/\.]+'
                  fi;
            reg2 = "(?<\(name)>\(reg))";
            
            if defined? mark then
                if defined? leading then
                    "(?:\(Pattern#quote(leading))" ^ reg2 ^ ")?" ;
                else
                    reg2 ^ "?";
                fi;
            else
                if defined? leading then
                    Pattern#quote(leading) ^ reg2
                else
                    reg2;
                fi;
            fi);
        Text tx:
           (Pattern#quote(tx));
        _ : failWith "should not happen";
        esac
    done
    |> strJoin "";
    
    regex = if strEnds? pat "/*" then
        push names "rest";
        reg ^ '(?:/(?<rest>.*))?'
    else
        reg
    fi;
    
    {
        names = nub names,
        regex
    }
    );

    

regexHandlerImpl method regexPattern handler = 
   (meth = strUpper method;
    var checkMethod? = meth != "ALL";
    
    {names, regex} = urlPatternToRegex regexPattern;
    pattern = Pattern#compile(regex);

    do octxt:
        oreq = request octxt;
        if checkMethod? and (meth != (strUpper oreq#getMethod())) then
            notHandled
        else
            matcher = pattern#matcher(oreq#getPathInfo() as ~java.lang.String);
            if matcher#matches() then
                nreq = new YebHttpServletRequestWrapper(true,oreq);

                //add the paramters
                urlParams = array [];
                for [0..matcher#groupCount()] do c:
                    push urlParams matcher#group(c);
                done;
                nreq#putParameters("urlParams", array urlParams);
                
                //add the named parameters
                for names do name:
                    nreq#putParameter(name, matcher#group(name));
                done;

                //set the new pathInfo and servletPath
                if (contains? "rest" names) and (defined? matcher#group("rest")) then
                    rest = matcher#group("rest");
                    matched = strLeft oreq#getPathInfo() 
                            ((strLength oreq#getPathInfo()) - (strLength rest)); 
                    nreq#setServletPath((oreq#getServletPath()) ^ matched);
                    nreq#setPathInfo(rest);
                else
                    nreq#setPathInfo("");
                    newServletPath = 
                        (oreq#getServletPath()) ^ (oreq#getPathInfo());
                    nreq#setServletPath(newServletPath);
                fi;
                nctxt = octxt with {req = nreq as ~HttpServletRequest};
                handler nctxt
            else
                notHandled
            fi;
        fi;
    done;
);

/**
 * Handleradapter which takes a request method and path pattern and executes on match
 * the given handler. Normally this is not used directly but a router is used.
 * The path pattern is the same as described in urlPatternToRegex.
 *
 * to handle the Get request for index:
 * :regexHandler (Get "index") do ctxt: ....; Completed "" done;
 */
regexHandler requestUrl handler = 
   ({fst = meth , snd = regexPattern} = 
        case requestUrl of
        Get us: pair "GET" us;
        Post us: pair "POST" us;
        Put us: pair "PUT" us;
        Delete us: pair "DELETE" us;
        Options us: pair "OPTIONS" us;
        Head us: pair "HEAD" us;
        All us: pair "ALL" us;
        esac;
    regexHandlerImpl meth regexPattern handler);
    
runHandlers handlers ctxt is list<handlerType<'a>> -> 'a -> handlerResult =
    if empty? handlers then
        notHandled
    else
        case (head handlers) ctxt of
            NotHandled x :
                runHandlers (tail handlers) ctxt;
            x : x;
        esac;
    fi;

lazyHandler moduleName  is string -> handlerType<'b> =
   (var myHandler is (Some handlerType<'b> | None () ) = none;
    loadHandler () = (
        cl = Thread#currentThread()#getContextClassLoader()#loadClass(moduleName);
        mod = cl#getMethod(
            "eval",() as ~Class[])#invoke(() as ~Object, () as ~Object[]);
        jmod = mod unsafely_as {handler is handlerType<'b>};
        h = jmod.handler;
        myHandler := Some h;
        h;
    );
    if not ((load org.yeb.mvc.config).webDynamicReload?) then
        loadHandler();
    else
        do ctxt:
            ha = case myHandler of
                Some h: h;
                None _ : loadHandler ();
            esac;
            ha ctxt;
        done;
    fi);

handlersFact oldVhs adapter= 
   (vhs = array [];
    {
		get adapter () = adapter,
        add handler =
            push vhs (adapter handler),
        
        pattern regex handler = add ((regexHandler regex) handler),
        _get regex handler = add ((regexHandler (Get regex)) handler),
        post regex handler = add ((regexHandler (Post regex)) handler),
        put regex handler = add ((regexHandler (Put regex)) handler),
        delete regex handler = add ((regexHandler (Delete regex)) handler),        
        options regex handler = add ((regexHandler (Options regex)) handler),
        head regex handler = add ((regexHandler (Head regex)) handler),
        
        all regex handler = add ((regexHandler (All regex)) handler),        

        lazy regex moduleName = 
            add $ (regexHandler (All regex)) (lazyHandler moduleName),

        get handler () =
            runHandlers (vhs ++ oldVhs),

        newSubRouter adapter =
            handlersFact (vhs ++ oldVhs) adapter,
    });
    
/**
 * Creates a router. A router is used to handle different requests.
 *
 * ie to specify differen request handlings do:
 * :router = newRouter id;
 * :router.get "index" do ctxt: //handle get request done
 * :router.post "someform" do ctxt: //handle post request done
 * :router.add customHandler; //use to add a handler which is always executed
 * :
 * :handler = router.handler; //cunstructs an handler for all the routes
 *
 * The router will than try to match any route in the order given and execute
 * the handlerfunction if it fits.
 *
 * Each handler function must return either 
 * - Completed if the request was handled by this handler and the async Request
 *   context can be closed 
 * - NotHandled "" if the reuqest is not handled by this handler and the next 
 *   routes/handlers should be tried to match
 * - Handling "" means that the right handler was found but the async RequestContext
 *   is kept open for further processing by the handler
 *
 * The router creates itself a handler with .handler. This handler can be used
 * directly in yebWebMain.handler or can be given to another router (with .add)
 * 
 * The adapter parameter is a function whith transforms each given handler to 
 * another handler. This adapter can be used to filter each request 
 *
 * ie to make sure each request is of a certain locale and has a logged in user:
 * 
 * :router = newRouter do handler ctxt:
 *       userId = (session ctxt)#getAttribute("userid")
 *       if defined? userId then
 *          handler (ctxt with {user = loadUserFromDb userId})
 *       else
 *          redirectView "login" ctxt
 *       fi
 *    done;
 * :router.get "members"
 */
 
newRouter adapter = handlersFact [] adapter;

/**
 * handler apdapter (filter) wich makes use that the local is one of
 * the specified locals.
 *
 * ie that each handler in the router only gets either an US or Italien locale
 * use:
 *
 * :import java.util.Locale;
 * :router = newRouter (localHandler [Locale#US, Locale#IT]);
 *
 */ 
localeHandler locales handler is list<~Locale> -> handlerAdapterType<'a> = 
   (if empty? locales then
       handler
    else
        lh = hash locales;
        defaultL = head locales;
        do ctxt:
            handler 
                if (request ctxt)#getLocale() in lh then 
                    ctxt
                else
                    nreq = 
                        new YebHttpServletRequestWrapper(false, (request ctxt));
                    nreq#setLocale(defaultL);
                    ctxt with {req = nreq as ~HttpServletRequest};
                fi;
        done;
    fi);




serviceHandlerSeperators = ["By": "", "From": "", "To": "", "At": ""];

/**
 * ServiceHandler takes a struct of functions and transform that functions
 * depending on their names in handler and transforms the result in a json representation
 */
serviceHandler service =
    case peekObject service of
    Struct {fields, value}:
       (serviceFuns = fields
            |> map do field: 
                import yeti.lang.Fun;
                fun = value field;
                if fun instanceof Fun then
                    ma = (like "((^any)|(^get)|(^post)|(^put)|(^delete))(.*)" field) ();
                    if not empty? ma then
                        method = ma.[1];
                        pl = (length ma);
                        fun = value unsafely_as ~Fun;
                        
                        name = ma.[pl - 1];
                        
                        var lastArg = 0;
                        names = matchAll "[A-Z][^A-Z]*" 
                            do partA:
                                part = partA.[0];
                                if part == "Params" then
                                    lastArg := 0;
                                    Some (Params())
                                elif part in serviceHandlerSeperators then
                                    lastArg := 1;
                                    none
                                else
                                    r = if lastArg == 1 then
                                        Some (Param (strLower part));
                                    else
                                        Some (Part (strLower part));
                                    fi;
                                    lastArg := 0;
                                    r
                                fi
                            done (Some . Part . strLower) name
                            |> catSome;
                        
                        
                        
                        
                        
                        pattern = names
                            |> filter do v:
                                case v of
                                Part f: true;
                                Param p: true;
                                _ : false;
                                esac
                            done
                            |> map do n:
                                case n of
                                Param na: ":\(na)";
                                Part na: na;
                                _ : failWith "internal error must not be anything else";
                                esac
                            done
                            |> strJoin "/";
                        
                        params = names 
                            |> filter do v:
                                case v of
                                Part _ : false;
                                _ : true;
                                esac
                            done;
                        
                        baseHandler = do ctxt:
                            res1 = fold 
                                do obj pa:
                                    if (obj is ~Object) instanceof Fun then
                                        fn = obj unsafely_as ~Fun;
                                        case pa of
                                        Param pn:
                                            maybeParam 
                                                pn 
                                                \(failWith "Excpeting param \(pa) but was not")
                                                do v:
                                                    fn#apply(E v) 
                                                done
                                                ctxt;
                                        Params _ :
                                            fn#apply(E ctxt);
                                        _ : fn;
                                        esac;
                                    else
                                        failWith "Function [\(field)] has too few params missing [\(pa)]";
                                    fi;
                                done
                                fun
                                params;
                            
                            
                            res = if (method == "post") or (method == "put") then
                                if res1 instanceof Fun then
                                    fn = res1 unsafely_as ~Fun;
                                    cont = getContents (readerHandle (request ctxt)#getReader());
                                    fn#apply(E cont);
                                else
                                    failWith "No function \(res1), but want to give in body";
                                fi
                            else
                                res1;
                            fi;
                                        
                            
                            resstr = 
                            if res instanceof Fun then
                                failWith "response is no struct and no string \(res)";
                            elif res instanceof yeti.lang.Struct then
                                (load org.yeb.json).write [] res;
                            elif res instanceof yeti.lang.Coll then
                                ls = (res unsafely_as ~yeti.lang.Coll)#asList();
                                (response ctxt)#setContentType("text/json;utf-8");
                                (load org.yeb.json).write[] ls;
                            else 
                                (response ctxt)#setContentType("text/plain;utf-8");
                                string res;
                            fi;
                            (response ctxt)#getWriter()#print(resstr);
                            Completed "";
                        done;
                        
                        handler = regexHandlerImpl method pattern baseHandler;
                        
                        Some handler
                    else
                        none
                    fi
                else
                    none
                fi
            done
            |> catSome;
        
        router = newRouter id;
        for serviceFuns router.add;
        router.handler);
    _ : failWith "service must be a struct with service functions";
    esac;


(load org.yeb.mvc.webutils) with {


    //makeNewCtxt,
    rootCtxt,
    mockCtxt,
	newMockHttpServletRequest,

    urlPatternToRegex,

    regexHandler,
    newRouter,
    localeHandler,
}

