/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module org.yeb.mvc.handler;



import java.lang:Thread, System, ClassLoader, Character, CharSequence;
import java.util: Locale, Date;
import java.util.regex:Pattern;
import java.util.concurrent.ConcurrentHashMap;
import java.text:NumberFormat, DecimalFormat, DateFormat, SimpleDateFormat;
import java.net: URLEncoder, URLDecoder;
import java.io:File;

import javax.servlet: ServletContext, FilterChain,ServletException,
                      AsyncContext;
import javax.servlet: Filter,FilterConfig,ServletRequest,ServletResponse;
import javax.servlet.http: HttpServletRequest, HttpServletResponse,HttpSession;

import org.springframework.mock.web: MockFilterConfig, MockServletContext, 
    MockHttpServletRequest, MockHttpServletResponse,MockFilterChain;
import org.springframework.web.util.WebUtils;

import yeti.lang: Fun, Struct;
import org.yeb:ValidationException, YebUtils;
load org.yeb.std;
load org.yeb.mvc.webutils;
load org.yeb.validation;

typedef resultType = {status is number};

typedef handlerType<a> = a -> resultType;
typedef handlerAdapterType<a> = handlerType<a> -> handlerType<a>;




handledStatusCode = 0;
goonStatusCode = -1;
skipStatusCode = -2;
asyncStatusCode = -3;
goonResult = {status = goonStatusCode};
skipResult = {status = skipStatusCode};
handledResult = {status = handledStatusCode};
asyncResult = {status = asyncStatusCode};


makeNewCtxt sctxt req res =
    {sctxt is ~ServletContext,
     req is ~HttpServletRequest,
     res is ~HttpServletResponse};

     
asyncCtxt ctxt =
   (requ = request ctxt;
    asyncCtxt = if not requ#isAsyncSupported() then
        failWith "asynch is not supported on this request"
    elif requ#isAsyncStarted() then
        requ#getAsyncContext()
    else
        requ#startAsync(requ, response ctxt);
    fi;
        
    ctxt with {
        sctxt is ~ServletContext = ctxt.sctxt,
        get req () = 
            asyncCtxt#getRequest() unsafely_as ~HttpServletRequest,
        get res () = 
            asyncCtxt#getResponse() unsafely_as ~HttpServletResponse,
        actxt is ~AsyncContext = asyncCtxt,
        complete () = asyncCtxt#complete()
    });
     
asyncListener fn =
   (import javax.servlet:AsyncListener, AsyncEvent;
    class TAsyncListener extends AsyncListener
        void onComplete(AsyncEvent ev)
            fn (OnComplete ev),
        void onError(AsyncEvent ev)
            fn (OnError ev),
        void onStartAsync(AsyncEvent ev)
            fn (OnStartAsync ev),
        void onTimeout(AsyncEvent ev)
            fn (OnTimeout ev)
    end;
    new TAsyncListener());
    
asyncHandler opts asyncHandler ctxt =
   (ac = asyncCtxt ctxt;
    _ = async opts \(asyncHandler ac);
    asyncResult);    
         
     

resultTH = threadLocal handledResult;

flashKey = "org.yeb.session.flash";

flashGetStruct ctx =
   (ra = (request ctx)#getAttribute(flashKey);
    if not defined? ra then
        failWith "no FlashContext: flash acces must be wrapped in a flashHandler";
    else
        ra unsafely_as {var oldMap is hash<string,~Object>, 
                        var newMap is hash<string, ~Object>}
    fi);

flashGet ctx key is 'b -> string -> (None () | Some 'a) = (
    fc = flashGetStruct ctx;
    if key in fc.newMap then
        Some (fc.newMap.[key] unsafely_as 'a);
    elif key in fc.oldMap then
        Some (fc.oldMap.[key] unsafely_as 'a);
    else
        none
    fi);

flashPut ctx key value =
   (flashGetStruct ctx).newMap.[key] := (value unsafely_as ~Object);
    
flashGetAndKeep ctx key =
   (r = flashGet ctx key;
    case r of
        Some v: flashPut ctx key v;
        None _: ();
    esac;
    r);

rootCtxt pathInfo sctxt req res  = 
   (reqn = new YebHttpServletRequestWrapper(() as ~Locale, "",
                                        pathInfo,() as ~java.util.Map, req);
    makeNewCtxt sctxt reqn res);



mockCtxt opts = 
   (var reqMethod = "GET";
    var reqPath = "/";
    var resourcePath = "test/resources/webapp";
    var headers = [:];
    var params = [:];
    for opts do opt:
        case opt of
        Get ruri : (reqMethod := "GET";reqPath := ruri);
        Head ruri : (reqMethod := "HEAD";reqPath := ruri);
        Post ruri : (reqMethod := "POST";reqPath := ruri);
        Put ruri : (reqMethod := "PUT";reqPath := ruri);
        Delete ruri : (reqMethod := "DELETE";reqPath := ruri);
        Trace ruri : (reqMethod := "TRACE";reqPath := ruri);
        Connect ruri : (reqMethod := "CONNET";reqPath := ruri);
        ResourcePath str: resourcePath := str;
        Header ha: forHash ha do k v: headers.[string k] := string v done;
        Param ha: forHash ha do k v: 
                params.[string k] := array [(string v) unsafely_as ~String] 
            done;
        Params ha : forHash ha do k v:
                params.[string k] := 
                    array (map do ve: 
                            (string ve) unsafely_as ~String 
                           done v)
            done;
        esac;
    done;


    mockServletCtxt = new MockServletContext(resourcePath);
    mockReq = new MockHttpServletRequest(mockServletCtxt,reqMethod, reqPath);
    mockRes = new MockHttpServletResponse();

    forHash params do k v:
        mockReq#addParameter(k,v);
    done;
    forHash headers do k v:
        mockReq#addHeader(k,v);
    done;

    ctxt = rootCtxt reqPath mockServletCtxt mockReq mockRes;
    nc = ctxt with {
        mockServletCtxt,
        mockReq,
        mockRes,
    };
    nc;
);


//HandlerAdapters


idHandler handler is handlerAdapterType<'a> = handler;

goonHandler ctxt is handlerType<'a> = goonResult;

urlPatternToRegex pat = YebUtils#patternToRegex((pat is string));

_regexHandler addLast? methodRegex handler is boolean -> string -> handlerAdapterType<'a> = (
    methodCut = strIndexOf methodRegex "::" 0;
    method = if methodCut == -1 then 
                "" 
             else 
                strUpper (strLeft methodRegex methodCut) 
             fi;
    method? = method != "";

    regex = if methodCut == -1 then 
                methodRegex 
            else 
                strRight methodRegex (methodCut +2) 
            fi;
    pattern = Pattern#compile(regex);

    do octxt:
        oreq = request octxt;
        if method? and (method != (strUpper oreq#getMethod() )) then
            goonResult
        else
            //mp is ~java.lang.String = (octxt.req)#getPathInfo();
            //matcher = pattern#matcher(mp as ~CharSequence);
            matcher = pattern#matcher(oreq#getPathInfo() as ~java.lang.String);
            matches? = if addLast? then 
                            matcher#lookingAt() 
                       else 
                            matcher#matches() 
                       fi; 
            if matches? then
                nreq = new YebHttpServletRequestWrapper(true,oreq);

                //add the paramters
                for [0..matcher#groupCount()] do c:
                    gn = "_\(c)";
                    nreq#putParameter(gn, matcher#group(c));
                done;

                //set the new pathInfo and servletPath
                if addLast? then
                    nsp = matcher#group();
                    nreq#setServletPath((oreq#getServletPath()) ^ nsp);
                    nreq#setPathInfo(
                        strRight (oreq#getPathInfo()) (strLength nsp));
                else
                    nreq#setPathInfo("");
                    newServletPath = 
                        (oreq#getServletPath()) ^ (oreq#getPathInfo());
                    nreq#setServletPath(newServletPath);
                fi;
                nctxt = octxt with {req = (nreq as ~HttpServletRequest)};
                handler nctxt
            else
                goonResult
            fi;
        fi;
    done;
);

regexHandler regex = _regexHandler false regex;

subRegexHandler regex = _regexHandler true regex;



ifHandler condition handler ctxt =
    if condition ctxt then
       handler ctxt
    else
       goonResult
    fi;



toHandler ac ctxt is ( 'b -> 'a) -> handlerType<'b> = (
    oldR = resultTH.value;
    resultTH.value := handledResult;
    try
        ac ctxt;
        resultTH.value;
       
    catch ValidationException e:
        goonResult
    finally
        resultTH.value := oldR;
    yrt;
);

runHandlers handlers ctxt is list<handlerType<'a>> -> 'a -> resultType =
    if empty? handlers then
        goonResult
    else
        r = (head handlers) ctxt;
        if r.status != goonStatusCode then
            r;
        else
            runHandlers (tail handlers) ctxt;
        fi
    fi;

lazyHandler moduleName  is string -> handlerType<'b> =
   (var myHandler is (Some handlerType<'b> | None () ) = none;
    loadHandler () = (
        cl = Thread#currentThread()#getContextClassLoader()#loadClass(moduleName);
        mod = cl#getMethod(
            "eval",() as ~Class[])#invoke(() as ~Object, () as ~Object[]);
        jmod = mod unsafely_as {handler is handlerType<'b>};
        h = jmod.handler;
        myHandler := Some h;
        h;
    );
    if not ((load org.yeb.mvc.config).webDynamicReload?) then
        loadHandler();
    else
        do ctxt:
            ha = case myHandler of
                Some h: h;
                None _ : loadHandler ();
            esac;
            ha ctxt;
        done;
    fi);

handlersFact oldVhs = 
   (vhs = array [];
    {
        add handler =
            push vhs handler,

        r regex handler = add $ (regexHandler regex) handler,
        rsub regex handler = add $ (subRegexHandler regex) handler,
        rlazy regex moduleName = 
            add $ (subRegexHandler regex) (lazyHandler moduleName),
        p regex handler = 
            add $ (regexHandler (urlPatternToRegex regex)) handler,
        psub regex handler = 
            add $ (subRegexHandler (urlPatternToRegex regex)) handler,
        plazy regex moduleName = 
            add $ (subRegexHandler (urlPatternToRegex regex)) 
                    (lazyHandler moduleName),

        get handler () =
            runHandlers ((reverse vhs) ++ oldVhs),

        get sub () =
            handlersFact ((reverse vhs) ++ oldVhs),
    });

handlers () = handlersFact [];

localHandler locales handler is list<~Locale> -> handlerAdapterType<'a> = 
   (if empty? locales then
       handler
    else
        lh = hash locales;
        defaultL = head locales;
        do ctxt:
            handler 
                if (request ctxt)#getLocale() in lh then 
                    ctxt
                else
                    nreq = 
                        new YebHttpServletRequestWrapper(false, (request ctxt));
                    nreq#setLocale(defaultL);
                    ctxt with {req = (nreq as ~HttpServletRequest)};
                fi;
        done;
    fi);



flashHandler handler ctxt is handlerAdapterType<'a> = 
   (sess = (request ctxt)#getSession(true);
    //synchronized on session lazly create the flash structure
    flashStruct = synchronized sess do _:
        f = sess#getAttribute(flashKey);
        flashStruct = if not defined? f then
            fr = {var oldMap = new java.util.HashMap(),
                  var newMap = new java.util.HashMap()};
            sess#setAttribute(flashKey, fr);
            fr;
        else
            f unsafely_as {var oldMap is ~java.util.HashMap,
                           var newMap is ~java.util.HashMap}
        fi;
        //store in the request
        (request ctxt)#setAttribute(flashKey,flashStruct);
        flashStruct;
    done;
    //synchronized on the flashstruct do the rest of the
    //request handling
    synchronized flashStruct do _:
        try
            handler ctxt
        finally
            //do the cleanup again synchronized on the session
            synchronized sess do _:
                flashStruct.oldMap#clear();
                om = flashStruct.oldMap;
                flashStruct.oldMap := flashStruct.newMap;
                flashStruct.newMap := om;
                sess#setAttribute(flashKey,flashStruct);
            done;
        yrt;
    done);


///forces teh creation of a session and synchronizes on the session if
///true on the frist argument
sessionHandler synchOnSession handler ctxt = 
   (session = (request ctxt)#getSession(true);
    if synchOnSession then
        mutex = WebUtils#getSessionMutex(session);
        synchronized mutex \(handler ctxt);
    else
        (handler is handlerType<'a>) ctxt
    fi);

initializedFilterHandler filter handler ctxt 
        is ~Filter -> handlerAdapterType<'a> = 
   (var res = goonResult;
   
    class MyChain extends FilterChain
        void doFilter(ServletRequest sreq, ServletResponse sres)
            res :=
                if (sreq instanceof HttpServletRequest) and
                   (sres instanceof HttpServletResponse)
                then
                    req = sreq unsafely_as ~HttpServletRequest;
                    res = sres unsafely_as ~HttpServletResponse;
                    if (same? req (request ctxt)) 
                       and (same? res (response ctxt)) then
                        handler ctxt
                    else
                        handler (ctxt with {req,res}) 
                    fi
                else
                    failWith "Filter did not transfer HttpServletRequest or HttpServletResponse";
                fi,
    end;
    filter#doFilter(request ctxt, response ctxt,new MyChain());
    res);
    
filterConfig ctxt fparams is ~ServletContext -> hash<string,string> -> 'a = 
   (import java.util:Enumeration, NoSuchElementException;
    params is hash<~String,~String> = fparams:!!!;

    class MyConfig extends FilterConfig
        String getFilterName()
            maybeAt \"filter: \(System#currentTimeMillis())" 
                    id "filterName":!!! 
                    params,

        String getInitParameter(String name)
            maybeAt \(() as ~String) id name:!!! params,

        ServletContext getServletContext() ctxt,

        Enumeration getInitParameterNames() (
            var names = keys params;
            class MyEnum extends Enumeration
                boolean hasMoreElements() not (empty? names),
                Object nextElement()
                    if empty? names then
                        throw new NoSuchElementException();
                    else
                        r = head names;
                        names := tail names;
                        r
                    fi,
            end;
            new MyEnum();
        ),
    end;
    new MyConfig());

filterHandler sctxt filter params 
        is 'b -> ~Filter -> hash<string,string> -> handlerAdapterType<'a> = 
   (cfg = filterConfig sctxt params;
    filter#init(cfg);
    initializedFilterHandler filter);




{

    handledStatusCode, 
    goonStatusCode,
    skipStatusCode,
    asyncStatusCode,
    goonResult,
    skipResult,
    handledResult,

    //makeNewCtxt,
    rootCtxt,
    mockCtxt,

    asyncHandler,
    asyncListener,
    
    request,
    response,
    locale, 
    servletContext,

    params,
    param,
    isAjax,

    flashKey, 
    flashGet, 
    flashPut,
    flashGetAndKeep,

    resultTH,

    urlPatternToRegex,

    idHandler, 
    goonHandler, 
    ifHandler,
    regexHandler,
    subRegexHandler,
    toHandler,
    runHandlers,
    sessionHandler,
    handlers,
    localHandler,
    flashHandler,

    initializedFilterHandler,
    filterConfig, 
    filterHandler,
}

