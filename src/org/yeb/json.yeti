/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module org.yeb.json;

import org.codehaus.jackson: JsonParser, JsonToken, JsonFactory, JsonGenerator,JsonEncoding;
import org.codehaus.jackson.map: ObjectMapper;
import java.lang: StringBuilder,Number,Double,Float;
import java.math: BigDecimal,BigInteger;
import java.util: Iterator, Map;
import yeti.lang: Num,FloatNum,IntNum,BigNum,TagCon,Fun;
import org.apache.commons.jxpath:JXPathContext;

std = load org.yeb.std;


//++++++++++++++++++++++++JSON Things +++++++++++++++++++++++++++++++++
jsonFactory = new JsonFactory();



toJSON stru = 
   (stw = new java.io.StringWriter();
    generator = jsonFactory#createJsonGenerator(stw);

    peekedWrite p = 
       (case p of
            Number num: generator#writeNumber(string num);
            String str : generator#writeString(string str);
            Boolean bo: generator#writeBoolean(bo);
            List l: (
                generator#writeStartArray();
                for l do e: peekedWrite e done;
                generator#writeEndArray();
            );
            Hash o: (
                generator#writeStartObject();
                forHash o do k v:
                    //k must be of string number or boolean
                    ks = case k of
                            String str: str;
                            Number num: string num;
                            Boolean bol: string bol;
                            x: failWith "Can not use as object name key: \(x)";
                          esac;
                    generator#writeFieldName(ks);
                    peekedWrite v;
                done;
                generator#writeEndObject();
            );
            Struct {fields, value}: (
                generator#writeStartObject();
                for fields do f:
                    generator#writeFieldName("\(f)");
                    peekedWrite (value f);
                done;
                generator#writeEndObject();
            );
            Variant {tag="None"}:
                generator#writeNull();
            Variant {tag="Some", value}:
                peekedWrite value;
            Variant {tag="Unpeeked", value}:
                peekedWrite value;
            Variant {tag,value} :
                generator#writeStartObject();
                generator#writeFieldName("variant");
                generator#writeString(tag);
                generator#writeFieldName("value");
                peekedWrite value;
                generator#writeEndObject();
            Object o :
                if o instanceof TagCon then
                    failWith "Can not write TagConstructor \(o)"
                elif o instanceof Fun then
                    failWith "Can not write Function \(o)"
                else
                    failWith "Can not write \(p)";
                fi
        esac);
    peekedWrite (peekObject stru);
    generator#flush();
    generator#close();
    stw#getBuffer()#toString());


    
//+++++++++++++++Parsing Json ++++++++++++++++++++++++++++++++++++++++

failUnpeek reason = std.failWithMessage (std.plainMessage reason);

    



unpeeker obj = {
    get str () = 
        if (obj is ~Object) instanceof String then 
            (obj unsafely_as string);
        else 
            failUnpeek "\(obj) is no string"
        fi,
    get num () = 
        case std.objectMaybeNum obj of
        None _ : failUnpeek "\(obj) is no number";
        Some n : n;
        esac,
    get bool () = 
        if obj instanceof Boolean then  
            (obj unsafely_as boolean);
        else 
            failUnpeek "\(obj) is no boolean"
        fi,
    some fn =
        if not defined? obj then
            none
        else
            Some (fn (unpeeker obj))
        fi,
    maybe noneFn fn = 
        if not defined? obj then
            noneFn ()
        else
            fn (unpeeker obj)
        fi,
    ls fn = 
        if obj instanceof java.util.List then
            mapJavaList (fn . unpeeker) (obj unsafely_as ~java.util.List);
        else
            failUnpeek "\(obj) is no list"
        fi,
    at name =     
        if obj instanceof java.util.Map then
            ma = obj unsafely_as ~java.util.Map;
            unpeeker ma#get(name);
        else
            failUnpeek "\(obj) is no map";
        fi,
    
    maybeAt name noneFn fn =    
        if obj instanceof java.util.Map then
            ma = obj unsafely_as ~java.util.Map;
            ro = ma#get(name);
            if defined? ro then
                fn (unpeeker ro)
            else
                noneFn ()
            fi
        else
            failUnpeek "\(obj) is no map";
        fi,
        
    someAt name fn =    
        if obj instanceof java.util.Map then
            ma = obj unsafely_as ~java.util.Map;
            ro = ma#get(name);
            if defined? ro then
                Some (fn (unpeeker ro))
            else
                none
            fi
        else
            failUnpeek "\(obj) is no map";
        fi};

ayxc () = (obx = unpeeker (() as ~Object);
_ = obx.str;
_ = obx.someAt "chris" (.str);
_ = obx.someAt "chris" (.num);
_ = obx.ls (.str);
_ = obx.ls (.num));





{

    toJSON,

    fromJSON jsonString = 
       (mapper = new ObjectMapper();
        jacksonParser = 
            jsonFactory#createJsonParser((jsonString is string) as ~String);
        ro = mapper#readValue(jacksonParser, (new Object())#getClass());
        if ro instanceof java.util.Map then
            mro = ro unsafely_as ~java.util.Map;
            unpeeker mro
        else 
            failUnpeek "\(ro) was no java map." 
        fi),




}