/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module org.yeb.json;

import net.minidev.json: JSONValue, JSONStyle;
import com.jayway.jsonpath:JsonPath;
//import org.codehaus.jackson.map: ObjectMapper;
import java.lang: StringBuilder,Number,Double,Float;
import java.math: BigDecimal,BigInteger;
import java.util: Iterator, Map;
import yeti.lang: Num,FloatNum,IntNum,BigNum,TagCon,Fun;
import org.apache.commons.jxpath:JXPathContext;

std = load org.yeb.std;


//++++++++++++++++++++++++JSON Things +++++++++++++++++++++++++++++++++

jsonFactory = new org.codehaus.jackson.JsonFactory();
(import org.codehaus.jackson: JsonParser, JsonParser$Feature;
    jsonFactory#configure(JsonParser$Feature#ALLOW_SINGLE_QUOTES, true);
    jsonFactory#configure(JsonParser$Feature#ALLOW_UNQUOTED_FIELD_NAMES, true);
    jsonFactory#configure(JsonParser$Feature#ALLOW_COMMENTS, true);
    jsonFactory#configure(JsonParser$Feature#ALLOW_NON_NUMERIC_NUMBERS, true);
    jsonFactory#configure(JsonParser$Feature#ALLOW_NUMERIC_LEADING_ZEROS, true);
    jsonFactory#configure(JsonParser$Feature#ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER, true));
    
    

fromJSON jsonStr = 
   (import org.codehaus.jackson: JsonParser, JsonToken, JsonFactory, JsonGenerator,JsonEncoding;
    jp = jsonFactory#createJsonParser((jsonStr) is string);
    readToken token =
        if nullptr? (token is ~JsonToken) then
            failWith "null token should not happen";
        elif token == JsonToken#VALUE_TRUE then
            Boolean#TRUE unsafely_as ~Object;
        elif token == JsonToken#VALUE_FALSE then
            Boolean#FALSE unsafely_as ~Object;
        elif token ==  JsonToken#VALUE_NUMBER_FLOAT then
            (jp#getDoubleValue()) unsafely_as ~Object;
        elif token == JsonToken#VALUE_NUMBER_INT then
            (jp#getLongValue()) unsafely_as ~Object;
        elif token == JsonToken#VALUE_STRING then
            (jp#getText()) unsafely_as ~Object;
        elif token == JsonToken#VALUE_NULL then
            () unsafely_as ~Object;
        elif token == JsonToken#START_ARRAY then
            ar = array [];
            var nextToken = jp#nextToken();
            ((not nullptr? nextToken) 
              and (nextToken != JsonToken#END_ARRAY)) loop
               (push ar (readToken nextToken);
                nextToken := jp#nextToken());
            (list ar) unsafely_as ~Object;
        elif token == JsonToken#START_OBJECT then
            ma = new java.util.HashMap();
            var nextToken = jp#nextToken();
            ((not nullptr? nextToken) 
              and (nextToken != JsonToken#END_OBJECT)) loop
               (name = strUncapitalize (string jp#getCurrentName());
                t = jp#nextToken();
                ma#put(name, readToken t);
                nextToken := jp#nextToken());
            new HashStruct(ma);
            /*
            curN = jp#getCurrentName();
            if (not nullptr? curN)
               and (contains? (string curN) hashes) then
                new yeti.lang.Hash(ma);
            else
                new yeti.lang.GenericStruct(ma);
            fi*/
        else 
            failWith "no allowed token";
        fi;
    r = readToken (jp#nextToken());    
    r unsafely_as 'a);


writeJSON opts stru  = 
   (stb = new StringBuilder();
    var style = JSONStyle#NO_COMPRESS;
    for opts do x: () done;
    
    append str = (stb#append(str is string); ());
    
    peekedWrite p = 
       (writeKV k v =
            (if not defined? k then append "null"
            elif not style#mustProtectKey(k) then append k
            else
                append '"';
                JSONValue#escape(k,stb,style);
                append '"';
            fi;
            append ":";
            peekedWrite(v));
            
                
       
        case p of
        Number num: append (string num); 
        String str : JSONValue#writeJSONString(str, stb, style);
        Boolean bo:
            append (if bo then "true" else "false" fi);
                
        List l: 
            if empty? l then
                append "null";
            else
                append "[";
                var first = true;
                for l do e:
                    if first then first := false else append "," fi;
                    peekedWrite e;
                done;
                append "]";
            fi;
        Hash o:
            if empty? o then
                append "null";
            else
                var first = true;
                append "{";
                forHash o do k v:
                    if first then first := false else append "," fi;
                    ke = case k of
                    Number n: string n;
                    String s: s;
                    Boolean b: string b;
                    _ : failWith "Only number, string or boolean types are supported as keys in hash";
                    esac;
                    writeKV ke v;
                done;
                append "}";
            fi;
            
        Struct {fields, value}: 
            if empty? fields then
                append "null";
            else
                var first = true;
                append "{";
                for fields do f:
                    if first then first := false else append "," fi;
                    writeKV f (value f);
                done;
                append "}"
            fi;
            
        Variant {tag="None"}:
            append "null";
        Variant {tag="Some", value}:
            peekedWrite value;
        Variant {tag="Unpeeked", value}:
            peekedWrite value;
        o : failWith "Can not write \(o)";
        esac);
    peekedWrite (peekObject stru);
    string stb#toString());


    
//+++++++++++++++Parsing Json ++++++++++++++++++++++++++++++++++++++++

failUnpeek reason = std.failWithMessage (std.plainMessage reason);

jsonStr obj =
    if (obj is ~Object) instanceof String then 
        (obj unsafely_as string);
    else 
        failUnpeek "\(obj) is no string"
    fi;

jsonNum obj =     
    case std.objectMaybeNum obj of
    None _ : failUnpeek "\(obj) is no number";
    Some n : n;
    esac;
    
jsonBool obj =
    if (obj is ~Object) instanceof Boolean then  
        (obj unsafely_as boolean);
    else 
        failUnpeek "\(obj) is no boolean"
    fi;

jsonList fn obj =
    if nullptr? (obj is ~Object) then
        []
    elif obj instanceof java.util.List then
        mapJavaList fn (obj unsafely_as ~java.util.List);
    elif obj instanceof java.util.Iterator then
        it = obj unsafely_as ~java.util.Iterator;
        itfn () =
            if it#hasNext() then 
                (fn it#next()) :. itfn
            else
                []
            fi;
        itfn ();
    else
        failUnpeek "\(obj) is no list"
    fi;

jsonHash kfn vfn obj =
    if nullptr? (obj is ~Object) then
        [:]
    elif obj instanceof java.util.Map then
        ret = [:];
        forJavaMap (obj unsafely_as ~java.util.Map) do k v:
            ret.[kfn k] := vfn v;
        done;
        ret;
    else
        failUnpeek "\(obj) is no map";
    fi;

jsonAt name obj=     
    if (obj is ~Object) instanceof java.util.Map then
        jma = (obj unsafely_as ~java.util.Map);
        jma#get(name);
    else
        failUnpeek "\(obj) is no map";
    fi;
 
jsonMAt name fn obj=
    if (obj is ~Object) instanceof java.util.Map then
        jma = (obj unsafely_as ~java.util.Map);
        r = jma#get(name);
        if nullptr? r then
            none;
        else
            Some (fn r);
        fi
    else
        failUnpeek "\(obj) is no map";
    fi;
    
jsonObj obje = {
    jmap = obje,
    at name = jsonAt name obje,
    str name = jsonAt name obje |> jsonStr,
    num name = jsonAt name obje |> jsonNum,
    bool name = jsonAt name obje |> jsonBool,
    obj name = jsonAt name obje |> jsonObj,
    hash name kfn vfn  = jsonAt name obje |> jsonHash kfn vfn,
    list name fn = jsonAt name obje |> jsonList fn,

    maybeAt name = jsonMAt name id obje,
    maybeStr name = jsonMAt name jsonStr obje,
    maybeNum name = jsonMAt name jsonNum obje,
    maybeBool name = jsonMAt name jsonBool obje,
    maybeObj name = jsonMAt name jsonObj obje,
    
    path name fn = 
        fn JsonPath#read(obje is ~Object, name is string)
};
    
        


{

    writeJSON,
    fromJSON,


    parseJSON jsonString = 
       jsonObj JSONValue#parseWithException(jsonString is string),
    
    parseJSONStrict jsonString =
       jsonObj JSONValue#parseStrict(jsonString is string),

    jsonStr, jsonNum, jsonBool, jsonList, jsonObj, jsonHash    

}