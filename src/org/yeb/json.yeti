/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module org.yeb.json;

import org.codehaus.jackson: JsonParser, JsonToken, JsonFactory, JsonGenerator,JsonEncoding;
import org.codehaus.jackson.map: ObjectMapper;
import java.lang: StringBuilder,Number,Double,Float;
import java.math: BigDecimal,BigInteger;
import java.util: Iterator, Map;
import yeti.lang: Num,FloatNum,IntNum,BigNum,TagCon,Fun;
import org.apache.commons.jxpath:JXPathContext;

std = load org.yeb.std;


//++++++++++++++++++++++++JSON Things +++++++++++++++++++++++++++++++++
jsonFactory = new JsonFactory();



toJSON stru = 
   (stw = new java.io.StringWriter();
    generator = jsonFactory#createJsonGenerator(stw);

    peekedWrite p = 
       (case p of
            Number num: generator#writeNumber(string num);
            String str : generator#writeString(string str);
            Boolean bo: generator#writeBoolean(bo);
            List l: (
                generator#writeStartArray();
                for l do e: peekedWrite e done;
                generator#writeEndArray();
            );
            Hash o: (
                generator#writeStartObject();
                forHash o do k v:
                    //k must be of string number or boolean
                    ks = case k of
                            String str: str;
                            Number num: string num;
                            Boolean bol: string bol;
                            x: failWith "Can not use as object name key: \(x)";
                          esac;
                    generator#writeFieldName(ks);
                    peekedWrite v;
                done;
                generator#writeEndObject();
            );
            Struct {fields, value}: (
                generator#writeStartObject();
                for fields do f:
                    generator#writeFieldName("\(f)");
                    peekedWrite (value f);
                done;
                generator#writeEndObject();
            );
            Variant {tag="None"}:
                generator#writeNull();
            Variant {tag="Some", value}:
                peekedWrite value;
            Variant {tag="Unpeeked", value}:
                peekedWrite value;
            Variant {tag,value} :
                generator#writeStartObject();
                generator#writeFieldName("variant");
                generator#writeString(tag);
                generator#writeFieldName("value");
                peekedWrite value;
                generator#writeEndObject();
            Object o :
                if o instanceof TagCon then
                    failWith "Can not write TagConstructor \(o)"
                elif o instanceof Fun then
                    failWith "Can not write Function \(o)"
                else
                    failWith "Can not write \(p)";
                fi
        esac);
    peekedWrite (peekObject stru);
    generator#flush();
    generator#close();
    stw#getBuffer()#toString());


    
//+++++++++++++++Parsing Json ++++++++++++++++++++++++++++++++++++++++

failUnpeek reason = std.failWithMessage (std.plainMessage reason);

    

unpeekStr o is ~Object -> 'a =
    if o instanceof String then (o unsafely_as string);
        else failUnpeek "\(o) is no string"
    fi;

unpeekNum o is ~Object -> 'a = 
    case std.objectMaybeNum o of
       None _ : failUnpeek "\(o) is no number";
       Some n : n;
    esac;

unpeekBool o is ~Object -> 'a =
    if o instanceof Boolean then  (o unsafely_as boolean);
        else failUnpeek "\(o) is no boolean"
    fi;

itToList mf ls jit 
    is (~Object -> 'c) -> list<'c> -> ~java.util.ListIterator -> list<'c> =
    if jit#hasPrevious() then
        el = mf jit#previous();
        ln = el :: ls;
        itToList mf ln jit;
    else
        ls
    fi;


unpeekList peeker o  is (~Object -> 'c) -> ~Object -> list<'c> =
    if o instanceof java.util.List then
        javaList = o unsafely_as ~java.util.List;
        it = javaList#listIterator(javaList#size());
        itToList peeker [] it;
    else failUnpeek "\(o) is no java.util.List"
    fi;

    
unpeekStru mapper obj is ('b -> 'c ) -> ~Object -> 'c= (
    if obj instanceof java.util.Map then
        ma = obj unsafely_as ~java.util.Map;
        mapper ma;
    else
        failUnpeek "\(obj) is no java.util.Map";
    fi;
);
 
unpeekHash keyPeeker valuePeeker o is (~Object-> 'a) -> (~Object -> 'b) -> ~Object -> hash<'a,'b> = (
    if o instanceof java.util.Map then
        ma = o unsafely_as ~java.util.Map;
        it = ma#keySet()#iterator();
        hashRet = [:];
        (it#hasNext()) loop (
            ko = it#next();
            vo = ma#get(ko);
            k = keyPeeker ko;
            v = valuePeeker vo;
            hashRet.[k] := v;
        );
        hashRet;
    else
        failUnpeek "\(o) is no java.util.Map";
    fi;
);

takeFromMap key unpeeker map is string -> (~Object -> 'a) ->  ~java.util.Map -> 'a = (
    v = map#get(key);
    if defined? v then
        unpeeker v;
    else
        failUnpeek "key \(key) does not exist in map \(map)";
    fi;

);


_itToList mf ls jit is 'a -> 'd -> ~java.util.Iterator -> 'c =
    if jit#hasNext() then
        _ = mf jit#next();
        ln = mf :: ls;
        _itToList mf ln jit;
    else
        ls
    fi;

_mapJavaIterator mapF javaIterator is 'a -> ~Iterator -> 'b = (
    li = _itToList mapF [] javaIterator;
    reverse li
);


unpeeker obj = {
    get str () = unpeekStr obj,
    get num () = unpeekNum obj,
    get bool () = unpeekBool obj,
    some fn =
        if not defined? obj then
            none
        else
            Some (fn (unpeeker obj))
        fi,
    maybe noneFn fn = 
        if not defined? obj then
            noneFn ()
        else
            fn (unpeeker obj)
        fi,
    ls fn = 
        if obj instanceof java.util.List then
            mapJavaList (fn . unpeeker) (obj unsafely_as ~java.util.List);
        else
            failUnpeek "\(obj) is no list"
        fi,
    at name =     
        if obj instanceof java.util.Map then
            ma = obj unsafely_as ~java.util.Map;
            unpeeker ma#get(name);
        else
            failUnpeek "\(obj) is no map";
        fi,
    
    maybeAt name noneFn fn =    
        if obj instanceof java.util.Map then
            ma = obj unsafely_as ~java.util.Map;
            ro = ma#get(name);
            if defined? ro then
                fn (unpeeker ro)
            else
                noneFn ()
            fi
        else
            failUnpeek "\(obj) is no map";
        fi,
        
    someAt name fn =    
        if obj instanceof java.util.Map then
            ma = obj unsafely_as ~java.util.Map;
            ro = ma#get(name);
            if defined? ro then
                Some (fn (unpeeker ro))
            else
                none
            fi
        else
            failUnpeek "\(obj) is no map";
        fi};

ayxc () = (obx = unpeeker (() as ~Object);
_ = obx.str;
_ = obx.someAt "chris" (.str);
_ = obx.someAt "chris" (.num);
_ = obx.ls (.str);
_ = obx.ls (.num));





{

    toJSON,

    //from JSON

    //jackson utilities



    jsonMap jsonString = (
        mapper = new ObjectMapper();
        jacksonParser = 
            jsonFactory#createJsonParser((jsonString is string) as ~String);
        ro = mapper#readValue(jacksonParser, (new Object())#getClass());
        if ro instanceof java.util.Map then
            ro unsafely_as ~java.util.Map;
        else failUnpeek "\(ro) was no java map." fi;
    ),


    jsTake unpeeker key map = takeFromMap key unpeeker map,
    jsStr name map = takeFromMap name unpeekStr map,
    jsNum name map = takeFromMap name unpeekNum map,
    jsBool name map = takeFromMap name unpeekBool map,
    jsStru mapper name map = takeFromMap name (unpeekStru mapper) map,
    jsList peeker name map = takeFromMap name (unpeekList peeker) map,
    jsHash keyPeeker valuePeeker name map = takeFromMap name (unpeekHash keyPeeker valuePeeker) map,

    xpath map is ~Map -> ~JXPathContext = JXPathContext#newContext(map),

    xpStr path jxc is string -> ~JXPathContext -> string = unpeekStr jxc#getValue(path),
    xpNum path jxc is string -> ~JXPathContext -> number = unpeekNum jxc#getValue(path),
    xpBool path jxc is string -> ~JXPathContext -> boolean = unpeekBool jxc#getValue(path),
    xpStru mapper path jxc is 'a -> string -> ~JXPathContext -> 'b = (unpeekStru mapper) jxc#getValue(path),
    xpList peeker path jxc is 'a -> string -> ~JXPathContext -> 'b = (unpeekList peeker) jxc#getValue(path),
    xpHash keyPeeker valuePeeker path jxc  is 'a -> 'b -> string -> ~JXPathContext -> 'c = (unpeekHash keyPeeker valuePeeker) jxc#getValue(path),
    xpTake unpeeker path jxc is 'a -> string -> ~JXPathContext -> 'c = unpeeker jxc#getValue(path),

    xpListStr path jxc is string -> ~JXPathContext -> 'c = _mapJavaIterator unpeekStr jxc#iterate(path),
    xpListNum path jxc is string -> ~JXPathContext -> 'c = _mapJavaIterator unpeekNum jxc#iterate(path),
    xpListBool path jxc is string -> ~JXPathContext -> 'c = _mapJavaIterator unpeekBool jxc#iterate(path),
    xpListStru mapper path jxc is 'a -> string -> ~JXPathContext -> 'c = _mapJavaIterator (unpeekStru mapper) jxc#iterate(path),
    xpListList peeker path jxc is 'a -> string -> ~JXPathContext -> 'c = _mapJavaIterator (unpeekList peeker) jxc#iterate(path),
    xpListHash keyPeeker valuePeeker path jxc is 'a -> 'b -> string -> ~JXPathContext -> 'c = _mapJavaIterator (unpeekHash keyPeeker valuePeeker) jxc#iterate(path),
    xpListTake unpeeker path jxc is 'a -> string -> ~JXPathContext -> 'c = _mapJavaIterator unpeeker jxc#iterate(path),


    unpeekStr, unpeekNum, unpeekBool, unpeekList, unpeekStru, unpeekHash


}