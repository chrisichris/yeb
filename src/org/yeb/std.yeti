/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module org.yeb.std;

import java.lang: String, Thread, ClassLoader, StringBuilder, Throwable;
import java.util: Locale, Iterator,List,ListIterator;

import yeti.lang.Struct;
import java.io: File;
//import org.yeb.TMap;
import org.slf4j: Logger, LoggerFactory;

class Message(String key, String defaultFormat, Object[] params) 
    
    message = String#format(defaultFormat, params),

    String getDefaultFormat() defaultFormat,
    String getKey() key,
    String getMessage() message,
    Object[] getParams() params,
    String getLocalMessage(Locale loc) 
        String#format(loc,defaultFormat,params),
    String toString() message,
end;

class MessageException(Message messageObject) 
    extends IllegalArgumentException(messageObject#getMessage()) 
    Message getMessageObject() messageObject,
    static MessageException create(Message msg)
        new MessageException( msg),
end;

class ValidationException(Message message, Object wrongValue) 
    extends MessageException(message)
    Object getWrongValue() wrongValue,
    static ValidationException create(Message msg, Object wV)
        new ValidationException(msg, wV),
end;


message key defaultFormat values =
    new Message(key, defaultFormat, array values);

plainMessage text = message "" text [];

failWithMessage msg = throw new MessageException(msg);

failWithValidation msg value =
    throw new ValidationException(msg, value unsafely_as ~Object);

newValidationException msg value =
    new ValidationException(msg, value unsafely_as ~Object);

validOr notValid valueFn =
    try
        valueFn ();
    catch MessageException ex:
        notValid;
    yrt;


validateFn notValidFn valueFn validFn value =
    try
        v = validFn value;
        valueFn v;
    catch MessageException ex:
        notValidFn ex;
    yrt;
        
maybeValid notValidFn validFn valueFn =
    validateFn notValidFn validFn valueFn (); 

stringWriter () = 
   (stB = new StringBuilder();
    {
        write str = (stB#append("\(str)");()),
        text () = string stB#toString(),
    });

objectMaybeNum o is ~Object -> ( None () | Some number ) = 
   (import java.lang: Double, Float,Number;
    import java.math: BigInteger, BigDecimal;
    import yeti.lang:Num,BigNum,IntNum,FloatNum;
    o2 = if (o instanceof Double) or
             (o instanceof Float) or
             (o instanceof BigDecimal)
             then
                nu = o unsafely_as ~Number;
                new FloatNum(nu#doubleValue());
        elif o instanceof BigInteger then
            nu = o unsafely_as ~BigInteger;
            new BigNum(nu);
        elif o instanceof Num then
            o unsafely_as ~Num;
        elif o instanceof Number then
            nu = o unsafely_as ~Number;
            new IntNum(nu#longValue());
        else o
        fi;
    if o2 instanceof Num then Some (o2 unsafely_as number) else none fi);

num x is 'a -> number = 
    maybe Double#NaN id (objectMaybeNum (x as ~Object));
    
nan? x = Double#isNaN(x is number);    
    
objectMaybeBoolean x is 'a -> (None () | Some boolean) =
    if x instanceof Boolean then
        Some (((x unsafely_as ~Object) unsafely_as ~Boolean)#booleanValue())
    else
        none
    fi;
    
boolean x is 'a -> boolean =
    (import java.lang.Number;
    o = x unsafely_as ~Object;
    case objectMaybeBoolean o of
        Some b:b;
        None _: 
            if (defined? x)
               or (nullptr? x)
               or ((o instanceof String) 
                    and ((o unsafely_as ~String)#length() == 0)) 
               or ((o instanceof Number) 
                   and ((o unsafely_as ~Number)#intValue() == 0))
            then 
                false
            else 
                true
            fi;
    esac);


withThreadLocal threadLocal newValue ac = 
   (oldV = threadLocal.value;
    threadLocal.value := newValue;
    try
        ac ();
    finally
        threadLocal.value := oldV;
    yrt);


defaultExecutor = 
   (import java.util.concurrent:Executors, ThreadFactory, TimeUnit;
    import java.lang: Thread, Runnable, Runtime,InterruptedException;

    class MyThF extends ThreadFactory
        Thread newThread(Runnable r)
            th = Executors#defaultThreadFactory()#newThread(r);
            th#setDaemon(true);
            th,
    end;
   
    exec = Executors#newCachedThreadPool(new MyThF());
    class ShutDR extends Runnable
        void run()
            try
                exec#shutdown();
                _ = exec#awaitTermination(2, TimeUnit#SECONDS);
                ()
            catch InterruptedException ex:
                ()
            yrt,
    end;
    Runtime#getRuntime()#addShutdownHook(new Thread(new ShutDR()));
    exec);

async opts fn   =
  (import java.util.concurrent:TimeUnit, Callable;
   var executor = defaultExecutor;
    var timeout = 1000;
    for opts do opt:
        case opt of
        Executor ex: executor := ex;
        Timeout tm: timeout := tm;
        esac
    done;
    
    fn2 is () -> 'a = fn;
    
    class Ca extends Callable
        Object call()
            (fn2()) unsafely_as ~Object 
    end;
    
    future = executor#submit(new Ca());
    r = if timeout < 1 then
        do (): future#get() done;
    else
        do ():future#get(timeout,TimeUnit#MILLISECONDS) done;
    fi;
    (r unsafely_as ~Object) unsafely_as () -> 'a);



getLogger name is string -> ~Logger = LoggerFactory#getLogger(name);


andThenEither fn fn2 a =
    case fn a of
    Left m: Left m;
    Right b: fn2 b;
    esac;


maybeHead noHead headF li =
    if empty? li then (noHead ()) else headF (head li) fi;

maybeAt noValue valueF k hs =
    if k in hs then valueF (hs.[k]) else (noValue k) fi;

listStarts? start l =
    if empty? start then
        true
    elif empty? l then
        false
    elif (head start) != (head l) then
        false
    else
        listStarts? (tail start) (tail l)
    fi;


maybeDefined defaultFn valueFn x =
    if defined? x then valueFn x else defaultFn () fi;

onDefined valueFn x = 
    if defined? x then Some (valueFn x) else none fi;
    
maybe' defaultFn fn opt =
    case opt of
    None x: defaultFn x;
    Some v: fn v;
    esac;



getSome opt = 
    case opt of
    None () : failWith "expects Some but was None";
    Some v : v;
    esac;

some v is 'a -> (Some 'a | None () )= Some v;

loadClass name =
    Thread#currentThread()#getContextClassLoader()#loadClass(name);


require cond msg =
  if not cond then
    throw new java.lang.IllegalArgumentException("\(msg)");
  fi;

ensure cond msg =
  if not cond then
    throw new java.lang.IllegalStateException("\(msg)");
  fi;

findCodeForException linesSourround sourceDirs ex =
    (prov = (load org.yeb.yeticlassloadermodule).sourceReader 
                    sourceDirs false
                    Thread#currentThread()#getContextClassLoader();

    exStack = 
        (rf exp exls = if nullptr? (exp is ~Throwable) then 
                    exls 
                else 
                    rf exp#getCause() (exp :: exls) 
                fi;
        reverse (rf ex []));
    exStack |> map do ex:
            stels = wrapArray (ex is ~Throwable)#getStackTrace()
                    |> map do ste:
                            arg = {
                                var name = string 
                                           (ste is ~java.lang.StackTraceElement)
                                           #getFileName(), 
                                fullpath = false
                            };
                            code = prov arg;
                            {fileName = arg.name,
                             code,
                             lineNumber = ste#getLineNumber()
                            } 
                       done
                    |> filter do {code}: code != undef_str done
                    |> map do {fileName,code,lineNumber}:
                            fromLineNumber = 
                                (max 0 (lineNumber -linesSourround)) + 1;
                            toLineNumber = lineNumber + linesSourround;
                            lines = list (strSplit '\n' code)
                                |> drop (fromLineNumber - 1)
                                |> take (2 *linesSourround);
                            {fileName,
                            lines,
                            lineNumber,
                            fromLineNumber,
                            toLineNumber};
                        done;
            {exception = ex, codeLines= stels}
        done) ;

simpleTest testHash ()=
   (var bad = 0;

    forHash testHash do name f:
        if not (f ()) then
            println "\(name) failed.";
            bad := bad + 1
        fi
    done;

    total = length testHash;
    if bad == 0 then
        "Testing done, \(total - bad)/\(total) OK."
    else
        "FAILURE: Testing done, \(total - bad)/\(total) OK."
    fi);

//+++++++++++++++++++++++table things ++++++++++++++++++++++++++++++++

typedef tableType<k,v> = {
   .add is k -> v -> tableType,
   .remove is k -> tableType,
   .valAt is k -> (None() | Some(v)),
   .count is number,
   .seq is () -> list<{key is k, value is v}>,
   .getDefault is 'k -> 'v -> 'v,
}

addAll table ha is tableType<'k,'v> -> hash<'k,'v> -> tableType<'k,'v>= 
    (var t = table;
    forHash ha do k v: t := (t.add k v) done;
    t);


create hash is hash<'k, 'v> -> tableType<'k,'v> = 
   (newTable pm is ~TMap -> tableType<'k,'v>  = 
       ({
          add k v is 'k -> 'v -> tableType<'k,'v> = newTable (pm#update(k,v)),

          remove k is 'k -> tableType<'k,'v> = newTable (pm#remove(k)),

          valAt k is 'k -> (None() | Some 'v) = (
            v = pm#get(k, TMap#NULL_VALUE);
            if same? v TMap#NULL_VALUE then None() else Some (v unsafely_as 'v)  fi
          ),

          getDefault key defaultV is 'k -> 'v -> 'v = (
            vr = pm#get(key,defaultV);
            vr unsafely_as 'v
          ),


          count is number= pm#size(),

          seq ()  = (
            r = pm#keyValueList();
            r unsafely_as list<{key is 'k ,value is 'v}>;
          ),
        } //unsafely_as tableType<'k,'v>
    );
    t = newTable TMap#EMPTY;
    if empty? hash then
        t;
    else 
       addAll t hash
    fi);

//----REACTOR--------------------------------------------------------

currentReactor = threadLocal none;

reactor opts = 
   (import java.util.concurrent.atomic:AtomicReference, AtomicInteger, 
                                       AtomicBoolean;
    import java.util.concurrent:Executor, ExecutorService;
    import java.lang:Runnable;
    
    var executor = defaultExecutor;
    for opts do opt:
        case opt of
        Executor exs: executor := exs;
        esac;
    done;
    
    running? = new AtomicBoolean(true);
    flushing = new AtomicBoolean(false);
    lock = new Object();
    var queue = array [];
    class FlushRunnable extends Runnable 
        void run()
            buffer = synchronized lock \(
                ((empty? queue) and running?#get()) loop
                    lock#wait();
                buffer = queue;
                queue := array [];
                buffer);
            
            if running?#get() then 
                for buffer do fn: fn() done;    
            
                _ = flushing#compareAndSet(true,false);
            
                if synchronized lock \(not empty? queue) then
                    if flushing#compareAndSet(false,true) then
                        executor#execute(this);
                    fi
                fi
            fi
    end;
    
    flushRunnable = new FlushRunnable();
   
    execute fn =
        if running?#get() then
            synchronized lock \(
                push queue fn;
                lock#notify());
            if flushing#compareAndSet(false,true) then
                executor#execute(flushRunnable);
            fi
        fi;
    p = {
        execute,
        get running? () = running?#get(),
        stop () = running?#set(false),
    };
    
    nexecute fn = withThreadLocal 
                currentReactor 
                (Some (p with {execute fn2 = nexecute fn2}))
                do: execute fn done;
    
    p with {execute fn = nexecute fn});

asyncPipe asyncFn receiverFn = 
    case currentReactor.value of
    Some reac :
        _ = async [] \(
            r = asyncFn ();
            reac.execute \(receiverFn r));
    None _ : 
        _ =receiverFn (asyncFn ());
    esac;
    
future timeout fn = 
   (import java.util.concurrent.atomic:AtomicMarkableReference;
    import java.util.concurrent:TimeoutException;
    ref = new AtomicMarkableReference(() as ~Object, false);
    lock = new Object();
    
    (fn is ( 'a -> () ) -> () ) do v :
       (if ref#isMarked() then
            failWith "value already set only set once";
        fi;
        synchronized lock \(
            _ = ref#set((v is 'a) unsafely_as ~Object,true);
            lock#notifyAll());
        ()
    done;
            
    do:
        synchronized lock \(
            ref#isMarked loop
                if timeout < 1 then
                    lock#wait();
                else
                    lock#wait(timeout)
                fi);
        if ref#isMarked() then
            ref#get() unsafely_as 'a;
        else 
            throw new TimeoutException();
        fi;
    done);
{       

    

    ($) x y = x y,
    (|>>) fn1 fn2 = composeToRight fn1 fn2,
    (|~>) fn1 fn2 = asyncPipe fn1 fn2;
    
    (:!) x is 'a -> 'b = x as ~Object,
    (:!!) x is ~Object -> 'a = x unsafely_as 'a,
    (:!!!) x is 'a -> 'b = x unsafely_as 'b,

    message,
    plainMessage,
    validOr, maybeValid,
    validateFn,
    failWithMessage,
    failWithValidation,
    newValidationException,

    getLogger,
    composeToRight fn1 fn2 = do a: fn2 (fn1 a) done,
    andThenEither,
    maybeHead,
    maybeAt,
    maybeDefined,
    onDefined,
    maybe',
    getSome,
    some,
    
    defaultExecutor,
    async,
    reactor,
    asyncPipe,
    

    withThreadLocal,

    loadClass,

    require,
    ensure,
    listStarts?,

    objectMaybeNum,
    num,
    objectMaybeBoolean,
    boolean,
    nan?,
    obj a = a as ~Object,
    simpleTest,

    stringWriter,

    randomList () = (
        import java.util.Random;
        ran = new Random();
        f () = ran#nextFloat()  :. f;
        f();
    ),

    forEach fun ls = for ls fun,

    findCodeForException,

    tableCreate = create,
    tableAddAll = addAll,
    tableRemoveAll table keys =
        fold do t k: tableRemove t k done table keys,

    tableAdd table k v is tableType<'k,'v> -> 'k -> 'v -> tableType<'k,'v>=
        table.add k v,

    tableRemove table k is tableType<'k,'v> -> 'k -> tableType<'k,'v> =
        table.remove k,

    tableAt table k is tableType<'k,'v> -> 'k -> (None() | Some('v)) =
        table.valAt k,

    tableLength table is tableType<'k,'v> -> number =
        table.count,

    tableKeyValues table is tableType<'k,'v> -> list<{key is 'k, value is 'v}> =
        table.seq(),

}