/*
 * Copyright 2011 Christian Essl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 */

module org.yeb.db;

import java.lang: StringBuilder, ThreadLocal,Throwable;
import java.sql:Connection, SQLException, SQLWarning, Statement,PreparedStatement, Types,ResultSet,Timestamp;
import javax.sql:DataSource;
import java.util.regex.Pattern;

load org.yeb.std;

typedef connectionFactoryType = () -> ~Connection;
typedef transactionMapType = {var current is None () | Some ~Connection, 
                              connections is hash<connectionFactoryType,~Connection>
                             }


typedef dataSourceType = {
    name is string,
    logger is ~org.slf4j.Logger,
    dataSource is ~DataSource,
    connectionTL is {var value is None () | Some ~Connection },
    transactionTL is {var value is number},
    withConnection is ~Object,
    withTransaction is ~Object,
    sqlUpdate is ~Object,
    sqlBaseQuery is ~Object,
    operateStatement is ~Object,
    queryTimeOut is number,
    maxRows is number,
    handleWarnings is string -> ~Statement -> (),
};

sqlWarningExceptionString warning is ~SQLWarning -> string = (
    if defined? warning then
        stb = new StringBuilder();
        stb#append("\n----SQLWarning----\n");
        var war = warning;
        (defined? war) loop (
            _ = stb#append("Message: [\(war#getMessage())] | SQLState: [\(war#getSQLState())] | ErrorCode: [\(war#getErrorCode())]");
            war := war#getNextWarning();
        );
        string (stb#toString());
    else
        ""
    fi;
);

someConnection ds is dataSourceType -> ( None () | Some ~Connection ) = ds.connectionTL.value;
connection? ds = maybe false \true (someConnection ds);
connection ds is 'a -> ~Connection = case someConnection ds of
                    None _ : failWith "No connection";
                    Some c : c;
                esac;


_withConnection ds code is dataSourceType -> 'a -> 'b = (
    ensure (not connection? ds) "there is already a connection ";
    dataSource = ds.dataSource;
    con = ds.dataSource#getConnection();
    try
        ds.connectionTL.value := Some con;
        code () //ds.connectionAdapter ds code;
    finally
        ds.connectionTL.value := none;
        if defined? con then
            con#close();
        fi
    yrt;
);

rollbackOnly? ds = ds.transactionTL.value == 2;
transaction? ds = ds.transactionTL.value > 0;
rollbackOnly ds =
    if ds.transactionTL.value > 0 then ds.transactionTL.value := 2 else failWith "No transaction running" fi;

tryRollbackOnly ds =
    if ds.transactionTL.value > 0 then ds.transactionTL.value := 2 else () fi;


_withTransaction ds code  is dataSourceType -> 'a -> 'b = (
    ensure (not transaction? ds) "There is already a transaction";
    con = connection ds;
    oldAutoCommit = con#getAutoCommit();
    con#setAutoCommit(false);
    ds.transactionTL.value := 1;
    try
        r = code();
        if ds.transactionTL.value == 2 then
            con#rollback();
        else
            con#commit();
        fi;
        r;
    catch Exception ex:
        con#rollback();
        throw ex;
    finally
        ds.transactionTL.value := 0;
        con#setAutoCommit(oldAutoCommit)
    yrt
);

_setStatementValue ps pos value is ~PreparedStatement -> number -> ~Object -> number = (
    import yeti.lang: Num,BigNum,RatNum,IntNum,FloatNum,AList, Tag;
    import java.lang: Number, String, CharSequence;
    import java.sql:Time, Timestamp;
    import java.util: Date,Calendar;

    var index = pos;
    if nullptr? value then
        //this is the empty list we set nothing
    elif (value instanceof Tag) and ((value unsafely_as ~Tag)#name == "Some") then
        t = (value unsafely_as ~Tag);
        index := _setStatementValue ps pos t#value;
        index := index -1; //decrease because below we increas and index is already at next position
    elif (value instanceof Tag) and ((value unsafely_as ~Tag)#name == "None") then
        //set to null
        //taken from springs StatementCreatorUtils (apache license)
        try
            dbmd = ps#getConnection()#getMetaData();
            databaseProductName = string dbmd#getDatabaseProductName();
            jdbcDriverName = string dbmd#getDriverName();
            if (strStarts? databaseProductName "Informix") or (strStarts? jdbcDriverName "Microsoft SQL Server") then
                //use setObject
                ps#setObject(index,() as ~Object);
            elif (strStarts? databaseProductName "DB2") or
                    (strStarts? jdbcDriverName "jConnect") or
                    (strStarts? jdbcDriverName "SQLServer") or
                    (strStarts? jdbcDriverName "Apache Derby") then
                //set with VARCHAR
                ps#setNull(index, Types#VARCHAR);
            else
                //set with null type
                ps#setNull(index,Types#NULL);
            fi;
        catch Throwable ex:
            //set with null type
            ps#setNull(index,Types#NULL);
        yrt

    elif value instanceof CharSequence then
        ps#setString(index, string value);
    elif (value instanceof Time) or (value instanceof Timestamp) or (value instanceof java.sql.Date) then
        ps#setObject(index,value);
    elif value instanceof Date then
        d = value unsafely_as ~Date;
        t = new Timestamp(d#getTime());
        ps#setTimestamp(index,t);
    elif value instanceof Calendar then
        c = value unsafely_as ~Calendar;
        t = new Timestamp(c#getTime()#getTime());
        ps#setTimestamp(index,t);
    elif (value instanceof IntNum) or (value instanceof BigNum) then
        n = value unsafely_as ~Number;
        ps#setLong(index,n#longValue());
    elif value instanceof Num then
        n = value unsafely_as ~Number;
        ps#setDouble(index,n#doubleValue());
    elif value instanceof AList then
        l = value unsafely_as list<~Object>;
        for l do v: index := _setStatementValue ps index v done;
        index := index -1; //decrease index because below we increas and it is already at next position
    elif value instanceof DBValue then
        dv = value unsafely_as ~DBValue;
        if dv#isNull() then
            ps#setNull(index,dv#getSqlType());
        else
            ps#setObject(index,dv#getValue(),dv#getSqlType());
        fi
    else
        ps#setObject(index,value);
    fi;
    index + 1;
);

_expandPattern = Pattern#compile('\?');
_expandSql sql params is string -> list<~Object> -> string = (
    import java.lang:StringBuffer,CharSequence;
    import yeti.lang:AList;

    m = _expandPattern#matcher(sql unsafely_as ~CharSequence);
    result = new StringBuffer();
    var rest = params;
    (m#find()) loop (
        if empty? rest then
            failWith "There are more questionmarks than params [\(length params)] in the sql: \(sql)"
        fi;
        param = head rest;
        rest := tail rest;

        questionMarks =
            if param instanceof AList then
                l = param unsafely_as list<'a>;
                strJoin "," (map \"?" l);
            elif nullptr? param then
                ""
            else
                "?"
            fi;
        m#appendReplacement(result, questionMarks);
    );
    m#appendTail(result);
    string result;
);


_operateStatement ds sql params statementHandler
        is dataSourceType -> string -> list<~Object> -> (string -> ~PreparedStatement -> 'a) -> 'a= (
    esql = _expandSql sql params;
    try
        ps = (connection ds)#prepareStatement(esql);
        try

            _ = _setStatementValue ps 1 (params:!);

            r = statementHandler esql ps;

            ds.handleWarnings esql ps;
            r
        finally
            ps#close()
        yrt;
    catch Exception ex:
        //println "Wrong Sql \(esql)";
        ds.logger#error("Wrong Sql [%1]",esql,ex);
        throw ex;
    yrt;
);

_sqlUpdate ds sql params
        is dataSourceType -> string -> list<~Object>  -> 'a=
    (ds.operateStatement:!!) ds sql params
            (_ sql ps is string -> ~PreparedStatement -> 'a = (rs is ~PreparedStatement = ps; rs#executeUpdate() ));

_sqlBaseQuery ds sql params resultSetHandler
        is dataSourceType -> string -> list<~Object> -> (~ResultSet -> 'a) -> 'a=
    (ds.operateStatement:!!) ds sql params
            (_ sql ps is string -> ~PreparedStatement -> 'a = (rs is ~PreparedStatement = ps; resultSetHandler (rs#executeQuery()) ));


defineDataSource name dataSource is string -> ~DataSource -> dataSourceType = {
    name,
    logger = getLogger name,
    dataSource,
    connectionTL = (m is None () | Some ~Connection = none; threadLocal m),
    transactionTL = threadLocal 0, //0 = no transation, 1 = active transaction to commit, 2 = active but rollback only
    withConnection = _withConnection:!,
    withTransaction = _withTransaction:!,
    sqlUpdate = _sqlUpdate:!,
    sqlBaseQuery = _sqlBaseQuery:!,
    operateStatement = _operateStatement:!,
    queryTimeOut = 0,
    maxRows = 0,
    handleWarnings sql statement is string -> ~Statement -> () =
        if defined? statement#getWarnings() then
            logger#info(sqlWarningExceptionString(statement#getWarnings()))
        fi,
};


typedef withHandlerType<a> = dataSourceType -> (() -> a) -> a

withConnection ds code is withHandlerType<'a> =
    if connection? ds then
        code ();
    else
        (ds.withConnection:!!) ds code;
    fi;

setConnectionHandler ds adapter
        is dataSourceType -> (withHandlerType<'a> -> withHandlerType<'a>) -> dataSourceType =
    ds with {withConnection = (adapter (ds.withConnection:!!)):!};

withTransaction ds code is withHandlerType<'a> =
    if transaction? ds then
        code ();
    elif connection? ds then
        (ds.withTransaction:!!) ds code;
    else
        withConnection ds \((ds.withTransaction:!!) ds code)
    fi;

setTransactionHandler ds adapter
        is dataSourceType -> (withHandlerType<'a> -> withHandlerType<'a>) -> dataSourceType =
    ds with {withTransaction = (adapter (ds.withTransaction:!!)):!};

typedef updateHandlerType = dataSourceType -> string -> list<~Object> -> number;

sqlUpdate ds sql params is  updateHandlerType =
    if transaction? ds then
        (ds.sqlUpdate:!!) ds sql params;
    else
        withTransaction ds \((ds.sqlUpdate:!!) ds sql params);
    fi;

setUpdateHandler ds adapter
        is dataSourceType -> (updateHandlerType -> updateHandlerType) -> dataSourceType =
    ds with {sqlUpdate = (adapter (ds.sqlUpdate:!!)):!};

typedef queryHandlerType<a> = dataSourceType -> string -> list<~Object> -> (~ResultSet -> a) -> a;

sqlBaseQuery ds sql params resultSetHandler
        is queryHandlerType<'a> =
    if transaction? ds then
        (ds.sqlBaseQuery:!!) ds sql params resultSetHandler;
    else
        withTransaction ds \((ds.sqlBaseQuery:!!) ds sql params resultSetHandler)
    fi;

setBaseQueryHandler ds adapter
        is dataSourceType -> (queryHandlerType<'a> -> queryHandlerType<'a>) -> dataSourceType =
    ds with { sqlBaseQuery = (adapter (ds.sqlBaseQuery:!!)):!};

///////////////////////////////////////////
//update helpers

sqlInsertEntity db tableName stru is dataSourceType -> string -> 'a -> number = (
    import yeti.lang: Struct;

    if (stru:!) instanceof Struct then
        ist = (stru:!) unsafely_as ~Struct;
        stb = new StringBuilder();
        stb#append("INSERT INTO \(tableName) (");

        values = array [];
        

        for [0 .. ist#count() -1] do i:
            
            //add names to sql
            name = string YebUtils#camelCaseToUnderline(ist#name(i));
            if i > 0 then stb#append(", "); fi;
            stb#append(name);

            //collect values 
            push values ist#get(i);
        done;

        stb#append(") VALUES (?)"); //the values list will be expanded to ? by sql update 

        sqlUpdate db stb#toString() [(list values):!];
    else 
        failWith "template must be a struct"
    fi;
);

sqlUpdateEntity db tableName stru whereClause whereParams is dataSourceType -> string -> 'a -> string -> list<~Object> -> number= (
    import yeti.lang: Struct;

    if (stru:!) instanceof Struct then
        ist = (stru:!) unsafely_as ~Struct;
        stb = new StringBuilder();
        stb#append("UPDATE \(tableName) SET ");

        values = array [];

        for [0 .. ist#count() -1] do i:

            //add names to sql
            name = string YebUtils#camelCaseToUnderline(ist#name(i));
            if i > 0 then stb#append(", "); fi;
            stb#append(name);
            stb#append(" = ?");

            //collect values
            push values ist#get(i);
        done;

        stb#append(" ");
        stb#append(whereClause);

        params = values ++ whereParams;
        sqlUpdate db stb#toString() params;
    else
        failWith "template must be a struct"
    fi;

);

sqlUpdateById db tableName stru is dataSourceType -> string -> 'a -> number= (
    import yeti.lang: Struct;

    if (stru:!) instanceof Struct then
        ist = (stru:!) unsafely_as ~Struct;
        stb = new StringBuilder();
        stb#append("UPDATE \(tableName) SET ");

        values = array [];
        var idField is ( None () | Some string ) = none;
        var idValue is ~Object = ():!;

        var first = true;
        for [0 .. ist#count() -1] do i:

            //add names to sql
            name = string YebUtils#camelCaseToUnderline(ist#name(i));

            if(name == "id") or (strEnds? name "_id") then
                idField := Some name;
                idValue := ist#get(i);
            else
                if first then first := false else stb#append(", "); fi;
                stb#append(name);
                stb#append(" = ?");

                //collect values
                push values ist#get(i);
            fi
        done;

        case idField of
            None _ : failWith "the struct must contain a 'id' or '*_id' field";
            Some n : (
                stb#append(" WHERE \(n) = ?");

                push values idValue;
                sqlUpdate db stb#toString() (list values);

            );
        esac;
    else
        failWith "template must be a struct"
    fi;

);

//////////////////////////////////////////
//query helpers



listResult rowHandler rs is (~ResultSet -> 'a) -> ~ResultSet -> list<'a> = (
    ret = array [];
    (rs#next()) loop push ret (rowHandler rs);
    list ret;
);

someResult rowHandler rs is (~ResultSet -> 'a) -> ~ResultSet -> ( None () | Some 'a ) =
    if rs#next() then Some (rowHandler rs) else none fi;


_resultSetValueToTemplate failText template dbValue is string -> 'a -> ~Object -> 'a= (
    import yeti.lang: Struct, GenericStruct, Num,BigNum,RatNum,IntNum,FloatNum,Tag;
    import java.lang: Number, String;


    ot is ~Object = template unsafely_as ~Object; 

    failT type = "\(failText): value [\(dbValue)] is [\(dbValue#getClass())]  but template [\(ot)] is [\(ot#getClass())]";

    ro = if not defined? dbValue then
        if ot instanceof Tag and (string (ot unsafely_as ~Tag)#name) == "Some" then
            none unsafely_as ~Object;
        else
            failWith "\(failText): The value was null but the template is not a None | Some variant";
        fi
    elif ot instanceof Tag then
        if  (string (ot unsafely_as ~Tag)#name) == "Some" then
            r = _resultSetValueToTemplate failText ((ot unsafely_as ~Tag)#value) dbValue;
            (Some r) unsafely_as ~Object;
        else
            failWith "\(failText): template is tag but only Some | None tags are supported";
        fi
    elif dbValue instanceof Number then
        num = (obj dbValue) unsafely_as ~Number;
        if (ot instanceof IntNum) or (ot instanceof BigNum) then
            new IntNum(num#longValue());
        elif (ot instanceof FloatNum) or (ot instanceof RatNum) then
            new FloatNum(num#doubleValue());
        elif (ot instanceof java.util.Date) then
            new java.util.Date(num#longValue());
        else
            failWith (failT "number");
        fi;
    elif ot#getClass()#isAssignableFrom((obj dbValue)#getClass()) then
        dbValue
    elif ot instanceof String then
        obj "\(dbValue)";
    else
        failWith "\(failText): template [\(template)] does not fit value [\(dbValue)]";
    fi;
    ro unsafely_as 'a;
);

singleValueRowHandler template rs is 'a -> ~ResultSet -> 'a =
    _resultSetValueToTemplate "" template rs#getObject(1);

toStructRowHandler template rs is 'a -> ~ResultSet -> 'a = (
    import yeti.lang: Struct, GenericStruct, Num,BigNum,RatNum,IntNum,FloatNum;

    o = template unsafely_as ~Object;
    if o instanceof Struct then
        tst = o unsafely_as ~Struct;
        
        mp is hash<string, ~Object> = [:];
        for [0 .. tst#count() -1] do i:
            name = string (tst#name(i));
            dbValue =
                if name =~ '^_\d+$' then
                    //we have a digit
                    rs#getObject((number (strRight name 1)) );
                else
                    uname = YebUtils#camelCaseToUnderline(name);
                    rs#getObject(uname);
                fi;
            mp.[name] := _resultSetValueToTemplate name tst#get(i) dbValue;
        done;
        (new GenericStruct(mp)) unsafely_as 'a
    else
        failWith "template must be a struct"
    fi;

);

sqlList ds sql setters rowHandler=
    sqlBaseQuery ds sql setters (listResult rowHandler);

sqlSome ds sql setters rowHandler =
    sqlBaseQuery ds sql setters (someResult rowHandler);

sqlListStruct ds sql setters template =
    sqlBaseQuery ds sql setters (listResult (toStructRowHandler template));

sqlSomeStruct ds sql setters template =
    sqlBaseQuery ds sql setters (someResult (toStructRowHandler template));

_selectClauseFromStruct stru = (
    import yeti.lang: Struct;
    if (stru:!) instanceof Struct then
        ist = (stru:!) unsafely_as ~Struct;
        stb = new StringBuilder();
        stb#append("SELECT ");

        for [0 .. ist#count() -1] do i:
            //add names to sql
            name = string YebUtils#camelCaseToUnderline(ist#name(i));
            if i > 0 then stb#append(", "); fi;
            stb#append(name);
            ()
        done;
        stb#toString();
    else
        failWith "template must be a struct"
    fi;

);

sqlSomeEntity db template fromWhereClause params = (
    sql = (_selectClauseFromStruct template) ^ " " ^ fromWhereClause;
    sqlSomeStruct db sql params template;
);

sqlListEntity db template fromWhereClause params = (
    sql = (_selectClauseFromStruct template) ^ " " ^ fromWhereClause;
    sqlListStruct db sql params template;
);

sqlSomeById db tableName stru is dataSourceType -> string -> 'a -> 'b= (
    import yeti.lang: Struct;

    if (stru:!) instanceof Struct then
        ist = (stru:!) unsafely_as ~Struct;

        var idField is ( None () | Some string ) = none;
        var idValue is ~Object = ():!;
        //find the id
        for [0 .. ist#count() -1] do i:
            name = string YebUtils#camelCaseToUnderline(ist#name(i));
           if(name == "id") or (strEnds? name "_id") then
                idField := Some name;
                idValue := ist#get(i);
            fi;
        done;

        case idField of
            None _ : failWith "the struct must contain a 'id' or '*_id' field";
            Some n : (
                whereClause = "FROM \(tableName) WHERE \(n) = ?";
                sqlSomeEntity db stru whereClause [idValue];
            );
        esac;
    else
        failWith "template must be a struct"
    fi;

);


sqlListValue ds sql setters template =
    sqlBaseQuery ds sql setters (listResult (singleValueRowHandler template));

sqlSomeValue ds sql setters template =
    sqlBaseQuery ds sql setters (someResult (singleValueRowHandler template));




//Helpers for handling datasource exception etc

sqlExceptionString seq is ~SQLException -> string = (
    ib ex sb is ~SQLException -> ~StringBuilder -> () = (
        _ = sb#append("SQLState: [\(ex#getSQLState())] | Error Code: [\(ex#getErrorCode())] | Message: [\(ex#getMessage())]\n");
        var t = ex#getCause();
        defined? t loop (
            _ = sb#append(string t)#append("\n");
            t := t#getCause();
        );
        if defined? ex#getNextException() then
            ib ex#getNextException() sb;
        fi;
    );
    stb = new StringBuilder();
    stb#append(string seq);
    stb#append(string seq#getStackTrace());
    ib seq stb;
    string (stb#toString());
);



{




sqlWarningExceptionString,
withConnection, someConnection, connection?, connection, withTransaction,

rollbackOnly?, transaction?, rollbackOnly, tryRollbackOnly,

defineDataSource,

sqlInsertEntity,
sqlUpdate,
sqlUpdateEntity,
sqlUpdateById,

sqlBaseQuery,
sqlList, sqlSome,
sqlListStruct, sqlSomeStruct,
sqlSomeEntity, sqlListEntity,
sqlListValue, sqlSomeValue,

sqlSomeById,


nullString = new DBValue((),Types#VARCHAR),
nullInt = new DBValue((),Types#BIGINT),
nullDouble = new DBValue((),Types#DOUBLE),
nullBoolean = new DBValue((),Types#BOOLEAN),
nullTimestamp = new DBValue((),Types#TIMESTAMP),


sqlExceptionString,


}










